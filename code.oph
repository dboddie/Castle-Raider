; Copyright (C) 2011 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $0e00

.include "constants.oph"

.alias max_row_offsets      $1f90 ; the furthest they can be displaced to the right
.alias initial_row_tiles    $1fb0 ; the tile occurring at the left edge of the screen
.alias row_indices          $1fc0 ; indices into each row of the level data
.alias initial_row_offsets  $1fd0 ; current displacements for the rows
.alias row_table_low        $1fe0
.alias row_table_high       $1ff0
.alias level_data_low       $00
.alias level_data_high      $20

.alias player_x             $1fa0
.alias player_y             $1fa1
.alias bank_number          $1fa2
.alias player_animation     $1fa3
.alias player_jumping       $1fa4
.alias player_moving        $1fa5
.alias player_falling       $1fa6

.alias scroll_offset_low    $8e
.alias scroll_offset_high   $8f

init:

    lda #22         ; MODE 5
    jsr $ffee
    lda #5
    jsr $ffee

    lda #23         ; disable flashing cursor
    jsr $ffee
    lda #1
    jsr $ffee
    ldx #7
    cursor_loop:
        lda #0
        jsr $ffee
        dex
        bpl cursor_loop
    
    jsr set_core_palette
    
    lda #19
    sta player_x
    lda #12
    sta player_y
    lda #2
    sta player_animation
    lda #0
    sta player_jumping
    sta player_moving
    sta player_falling
    
    lda #1              ; Use 1 and 2 for banks 1 and 2.
    sta bank_number

main:

    jsr clear_bank1
    jsr clear_bank2
    
    jsr init_scrolling
    
    jsr show_bank2          ; Hide the bank being plotted.
    jsr initial_plot_bank1
    jsr plot_char_bank1
    jsr show_bank1          ; Show the completed bank.
    jsr initial_plot_bank2
    
    lda #0
    sta scroll_offset_low
    lda #0
    sta scroll_offset_high
    
    main_loop:
    
        lda player_jumping
        cmp #0
        bne main_loop_check_fall
        
            jsr check_beneath
        
        main_loop_check_fall:
        
        lda player_falling
        cmp #0
        beq main_loop_allow_movement
        
            lda player_moving
            cmp #1
            bne main_loop_not_moving_left
            
            jsr player_move_left
            jmp main_loop_next
            
            main_loop_not_moving_left:
            
            cmp #2
            bne main_loop_not_moving_right
            
            jsr player_move_right
            jmp main_loop_next
            
            main_loop_not_moving_right:
            
            lda #19
            jsr $fff4
            jsr plot_player
        
            inc player_y
            jsr plot_player
        
        main_loop_allow_movement:
        
            clc
            
            jsr player_move
            jmp main_loop_next
        
        main_loop_next:
        
        clc
        
        ldx #157            ; (SPACE)
        jsr check_key
        cpy #255
        bne not_space
        
        clc
        jsr initial_plot_bank1
        jsr initial_plot_bank2
        lda bank_number
        cmp #1
        bne not_bank1
        clc
        jsr plot_char_bank1
        jmp not_space
        
        not_bank1:
        jsr plot_char_bank2
        
        not_space:
        
        ldx #143            ; (Escape)
        jsr check_key
        cpy #255
        bne main_loop
    
    main_loop_endloop:
    
    clc
    rts

player_move:

    lda player_jumping
    cmp #0
    beq player_move_check_fall
    clc
    
    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot
    
    jsr player_jump
    
    jsr plot_player                 ; plot
    
    lda player_moving
    cmp #1
    bne player_move_not_moving_left
    
    jsr player_move_left
    
    player_move_not_moving_left:
    cmp #2
    bne player_move_not_moving_right
    
    jsr player_move_right
    
    player_move_not_moving_right:
    
    clc
    rts
    
    player_move_check_fall:
    
    lda player_falling
    cmp #0
    beq player_move_check_keys
    
    clc
    rts
    
    player_move_check_keys:
    
    lda #0
    sta player_moving
    
    ldx #158        ; (Z)
    jsr check_key
    cpy #255
    bne player_move_not_left
    clc
    
    jsr player_move_left   ; allow the player to jump while moving
    
    lda #1                  ; 1=moving left
    sta player_moving
    
    jmp player_move_check_jump

    player_move_not_left:
    clc
    
    ldx #189        ; (X)
    jsr check_key
    cpy #255
    bne player_move_not_right
    clc
    
    jsr player_move_right   ; allow the player to jump while moving
    
    lda #2                  ; 2=moving right
    sta player_moving
    
    ; jmp player_move_check_jump (fall through)

    player_move_not_right:
    
    player_move_check_jump:
    
    lda player_jumping
    cmp #0
    bne player_move_not_jump
    
    ldx #182        ; (Return)
    jsr check_key
    cpy #255
    bne player_move_not_jump
    clc
    
    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot
    
    jsr player_jump
    
    jsr plot_player                 ; plot
    
    player_move_not_jump:
    
    clc
    rts

scroll_right_update:

    lda bank_number
    cmp #2              ; showing bank 2?
    beq scroll_right_update_show_bank1
    
    lda scroll_offset_low
    cmp #level_extent_low
    bne scroll_right_update_ok_to_scroll
    lda scroll_offset_high
    cmp #level_extent_high
    bne scroll_right_update_ok_to_scroll
    
    clc
    rts
    
    scroll_right_update_ok_to_scroll:
    clc
    
    jsr plot_bank2r
    lda #19
    jsr $fff4
    jsr show_bank2
    
    jsr scroll_update_bank1_bank2
    
    lda player_animation
    ora #$02
    sta player_animation
    
    jsr plot_char_bank2 ; plot the player on bank 2
    
    clc
    rts
    
    scroll_right_update_show_bank1:
    clc
    
    lda scroll_offset_low   ; Increase the scroll offset before showing bank 1.
    adc #1
    sta scroll_offset_low
    lda scroll_offset_high
    adc #0
    sta scroll_offset_high
    clc
    
    jsr scroll_right
    
    jsr plot_bank1r
    lda #19
    jsr $fff4
    jsr show_bank1
    
    jsr scroll_update_bank2_bank1
    
    lda player_animation
    ora #$02
    sta player_animation
    
    jsr plot_char_bank1 ; plot the player on bank 1
    
    clc
    rts

scroll_left_update:

    lda bank_number
    cmp #2              ; showing bank 2?
    beq scroll_left_update_show_bank1
    
    lda scroll_offset_low
    cmp #0
    bne scroll_left_update_ok_to_scroll
    lda scroll_offset_high
    cmp #0
    bne scroll_left_update_ok_to_scroll
    
    clc
    rts
    
    scroll_left_update_ok_to_scroll:
    clc
    
    jsr scroll_left
    
    jsr plot_bank2l
    lda #19
    jsr $fff4
    jsr show_bank2
    
    jsr scroll_update_bank1_bank2
    
    lda player_animation
    and #$01
    sta player_animation
    
    jsr plot_char_bank2 ; plot the player on bank 2
    
    lda scroll_offset_low   ; Decrease the scroll offset after showing bank 2.
    sec
    sbc #1
    sta scroll_offset_low
    lda scroll_offset_high
    sbc #0
    sta scroll_offset_high
    clc
    
    clc
    rts
    
    scroll_left_update_show_bank1:
    clc
    
    jsr plot_bank1l
    lda #19
    jsr $fff4
    jsr show_bank1
    
    jsr scroll_update_bank2_bank1
    
    lda player_animation
    and #$01
    sta player_animation
    
    jsr plot_char_bank1 ; plot the player on bank 1
    
    clc
    rts

scroll_update_bank2_bank1:

    jsr plot_char_bank2 ; unplot the player on bank 2
    
    lda player_animation
    eor #1
    sta player_animation
    
    lda player_falling
    cmp #0
    beq scroll_update_plot_bank1
    
    inc player_y
    
    scroll_update_plot_bank1:
    clc
    
    lda #1
    sta bank_number
    
    clc
    rts

scroll_update_bank1_bank2:

    jsr plot_char_bank1 ; unplot the player on bank 1
    
    lda player_falling
    cmp #0
    beq scroll_update_plot_bank2
    
    inc player_y
    
    scroll_update_plot_bank2:
    clc
    
    lda #2
    sta bank_number
    
    clc
    rts

check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jsr $fff4
    rts

check_beneath:

    lda player_y
    cmp #13
    bpl check_beneath_exit
    
    adc #3
    sta $71
    lda player_x
    sta $70
    
    jsr check_tile
    cmp #0
    bne check_beneath_exit
    
    clc
    inc $70
    jsr check_tile
    cmp #0
    bne check_beneath_exit
    
    lda bank_number         ; When half way across a cell, check another cell
    cmp #2                  ; beneath the player since they could be standing
    bne check_beneath_fall  ; on one or more of three tiles.
    
    clc
    inc $70
    jsr check_tile
    cmp #0
    bne check_beneath_exit
    
    check_beneath_fall:
    
    lda #1
    sta player_falling
    clc
    rts
    
    check_beneath_exit:
    
    cmp #$10                        ; Tiles >= 16 are trigger tiles.
    bcc check_beneath_no_trigger
    
    jsr invoke_action
    
    check_beneath_no_trigger:
    
    lda #0
    sta player_falling
    clc
    rts

invoke_action:                      ; A=trigger tile number

    ; Determine which action should be invoked.
    
    tay                     ; The tile number has the format, aaaxtttt, where
    and #$e0                ; the bottom 5 bits are the tile sprite and the
    sta $84                 ; top three bits are the action group. We need to
    tya                     ; process this value to get aaatttt0, which is the
    and #$0f                ; action number multiplied by two.
    asl                     ; This provides an offset into the action address
    ora $84                 ; table.
    
    tax
    lda actions_address,x   ; Read the low byte of the action address from the
                            ; action address table.
    sta $70
    sta $84
    inx
    lda actions_address,x   ; Read the high byte of the action address from the
                            ; action address table.
    sta $71
    sta $85
    
                            ; Offset 0 is the initial tile type.
    ldy #1
    lda ($70),y             ; Offset 1 is the final tile type.
    sta $74
    sta $86
    iny
    lda ($70),y             ; Read the number of spans to change.
    sta $87
    tax
    
    invoke_action_loop:
    
        iny
        lda ($70),y         ; low byte of span address
        sta $72
        iny
        lda ($70),y         ; high byte of span address
        sta $73
        
        sty $80
        
        lda $74
        ldy #0
        cmp ($72),y
        bne invoke_action_loop_apply
        
        clc ; If the span has already been applied then exit because the other
        rts ; spans will also have been applied.
        
        invoke_action_loop_apply:
        sta ($72),y
        
        ldy $80
        
        dex
        bpl invoke_action_loop
    
    clc
    
    ;jsr initial_plot_bank1
    ;jsr plot_char_bank1
    ;jsr initial_plot_bank2
    
    clc
    rts

clear_bank1:

    lda #$00
    sta $70
    lda #$30
    sta $71
    ldy #0
    
    clear_bank1_loop:
    
        lda #0
        sta ($70),y
        
        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc
        
        cmp #$58
        bne clear_bank1_loop
    
    clc
    rts

clear_bank2:

    lda #$00
    sta $70
    lda #$58
    sta $71
    ldy #0
    
    clear_bank2_loop:
    
        lda #0
        sta ($70),y
        
        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc
        
        cmp #$80
        bne clear_bank2_loop
    
    clc
    rts

show_bank1:

    lda #$00
    sta $fe02
    lda #$18
    sta $fe03
    clc
    rts

show_bank2:

    lda #$00
    sta $fe02
    lda #$2c
    sta $fe03
    clc
    rts

set_core_palette:

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    rts

set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $3dfb
    lda $71
    sta $3dfc
    lda #0
    sta $3dfd
    sta $3dfe
    sta $3dff

    lda #$c         
    ldx #$fb
    ldy #$3d
    jsr $fff1
    rts

bank1_rows_low:  .byte  $00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0
bank1_rows_high: .byte  $3a,$3b,$3c,$3d,$3f,$40,$41,$42,$44,$45,$46,$47,$49,$4a,$4b,$4c
bank2_rows_low:  .byte  $00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0
bank2_rows_high: .byte  $62,$63,$64,$65,$67,$68,$69,$6a,$6c,$6d,$6e,$6f,$71,$72,$73,$74

init_scrolling:

    ldx #15
    init_banks_loop:
    
        lda #0
        sta row_indices,x
        sta initial_row_tiles,x
        sta initial_row_offsets,x
        sta max_row_offsets,x
        dex
        bpl init_banks_loop
    
    clc
    rts

plot_bank1r:

    ldx #15          ; row number
    
    plot_bank1r_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.

        cmp #40
        bcc plot_bank1r_row_loop_calculate_row_address
        
        dex
        bpl plot_bank1r_row_loop     ; Loop again or exit.
        clc
        rts
        
        plot_bank1r_row_loop_calculate_row_address:
        
        sta $74
        jsr read_screen_address_bank1
        
        plot_bank1r_offset_loop:
        
            ldy #0
            lda ($76),y             ; Load the type number, t,
            and #$1f                ; mask off the top 3 bits,
            jsr read_sprite_address
            jsr plot_tile_bank
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            adc #1              ; n
            bcs plot_bank1r_offset_endloop
            
            tay                 ; temp (n)
            adc $74             ; Add n to o.
            clc
            
            cmp #40
            bcs plot_bank1r_offset_endloop
            sta $74

            tya                 ; temp (n)
            asl
            asl
            asl                 ; n*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73             ; x ($72,$73)
            clc
            
            lda $76             ; Add 2 to I.
            adc #2
            sta $76
            bcc plot_bank1r_offset_loop
            
            lda $77
            adc #0
            sta $77
            clc
            
            jmp plot_bank1r_offset_loop
        
        plot_bank1r_offset_endloop:
        clc
        
        dex
        bmi plot_bank1r_row_endloop
        jmp plot_bank1r_row_loop
    
    plot_bank1r_row_endloop:
    clc
    rts

plot_bank1l:

    ldx #15          ; row number
    
    plot_bank1l_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.

        cmp #41
        bcc plot_bank1l_row_loop_calculate_row_address
        
        dex
        bpl plot_bank1l_row_loop     ; Loop again or exit.
        clc
        rts
        
        plot_bank1l_row_loop_calculate_row_address:
        sta $74
        
        cmp #0
        beq plot_bank1l_skip_leading_tile
        
            clc
            jsr read_screen_address_bank1

            lda $72
            sec
            sbc #8
            sta $72
            lda $73
            sbc #0
            sta $73
            clc

            lda initial_row_tiles,x     ; Load the initial tile type,
            and #$1f                    ; mask off the top 3 bits.
            jsr read_sprite_address

            jmp plot_bank1l_offset_loop
        
        plot_bank1l_skip_leading_tile:
        clc
        
            lda bank1_rows_low,x    ; Use the screen start address for the
            sta $72                 ; row, R, to get x.
            lda bank1_rows_high,x
            sta $73                 ; x ($72,$73)
            clc
            
            lda $72     ; The leading tile would be plotted off the left hand
            sec         ; side of the screen.
            sbc #8
            sta $72
            lda $73
            sbc #0
            sta $73
            clc
            
            jmp plot_bank1l_offset_loop_span
        
        plot_bank1l_offset_loop:
        
            jsr plot_tile_bank
            
            plot_bank1l_offset_loop_span:
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            adc #1
            bcs plot_bank1l_offset_endloop
            
            tay                 ; temp (n)
            adc $74             ; Add n to o.
            clc
            
            cmp #41
            bcs plot_bank1l_offset_endloop
            sta $74

            tya                 ; temp (n)
            asl
            asl
            asl                 ; n*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73             ; x ($72,$73)
            clc
            
            ldy #0
            lda ($76),y             ; Load the type number, t,
            and #$1f                ; mask off the top 3 bits,
            jsr read_sprite_address
            
            lda $76             ; Add 2 to I.
            adc #2
            sta $76
            bcc plot_bank1l_offset_loop
            
            lda $77
            adc #0
            sta $77
            clc
            
            jmp plot_bank1l_offset_loop
        
        plot_bank1l_offset_endloop:
        clc
        
        dex
        bmi plot_bank1l_row_endloop
        jmp plot_bank1l_row_loop
    
    plot_bank1l_row_endloop:
    clc
    rts

plot_tile_bank:     ; $70,$71 source address
                    ; $72,$73 screen address

    ldy #7
    plot_tile_bank_loop:
    
        lda ($70),y
        sta ($72),y
        dey
        bpl plot_tile_bank_loop
    
    clc
    rts

plot_merged_tile_bank:  ; $70,$71 source address 1
                        ; $72,$73 screen address
                        ; $80,$81 source address 2

    ldy #7
    plot_merged_tile_bank_loop:
    
        lda ($70),y
        ora ($80),y
        sta ($72),y
        dey
        bpl plot_merged_tile_bank_loop
    
    clc
    rts

scroll_right:

    ldx #15
    scroll_right_loop:
    
        lda initial_row_offsets,x
        cmp #0
        beq scroll_right_loop_next_offset
        
        dec initial_row_offsets,x
        
        dex
        bpl scroll_right_loop
        
        clc
        rts
        
        scroll_right_loop_next_offset:
        clc
        
        jsr read_row_address    ; read the row address before we update the index
        
        inc row_indices,x   ; increment the index to refer to the next span
        
        ldy #0
        lda ($76),y             ; load the tile type for the current span
        sta initial_row_tiles,x ; store the tile type
        
        ldy #1              ; load the number of tiles left in the current span
        lda ($76),y         ; minus 1 (n - 1)
        sta initial_row_offsets,x
        sta max_row_offsets,x
        
        dex
        bpl scroll_right_loop
    
    clc
    rts

scroll_left:

    ldx #15
    scroll_left_loop:
    
        lda initial_row_offsets,x
        cmp max_row_offsets,x
        beq scroll_left_loop_previous_offset
        
        inc initial_row_offsets,x
        
        dex
        bpl scroll_left_loop
        
        clc
        rts
        
        scroll_left_loop_previous_offset:
        clc
        
        dec row_indices,x   ; decrement the index to refer to the previous span
        
        jsr read_row_address    ; read the row address for the previous span
        
        lda $76             ; refer to the span before the previous span, p'
        sec
        sbc #2
        sta $76
        lda $77
        sbc #0
        sta $77
        clc
        
        ldy #0
        lda ($76),y             ; load the tile type for span p'
        and #$1f                ; mask off the top 3 bits,
        sta initial_row_tiles,x ; store the tile type
        
        ldy #1                  ; load the number of tiles in span p'
        lda ($76),y             ; minus 1 (n - 1)
        sta max_row_offsets,x   ; store this value as the maximum row offset
                                ; for the previous span
        
        lda #0
        sta initial_row_offsets,x   ; set the initial row offset of the previous
                                    ; span
        
        dex
        bpl scroll_left_loop
    
    clc
    rts

plot_bank2r:

    ldx #15          ; row number
    
    plot_bank2r_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.
        cmp #41
        bcc plot_bank2r_row_loop_calculate_row_address
        
            dex
            bpl plot_bank2r_row_loop
            clc
            rts
        
        plot_bank2r_row_loop_calculate_row_address:
        
        sta $74
        jsr read_screen_address_bank2
        
        lda initial_row_tiles,x         ; Load the initial tile type,
        and #$1f                        ; mask off the top 3 bits.
        sta $78
        
        lda $74
        cmp #0
        beq plot_bank2r_row_loop_skip_leading
        cmp #41
        bcc plot_bank2r_row_loop_plot_leading
        
            dex
            bpl plot_bank2r_row_loop
            clc
            rts
        
        plot_bank2r_row_loop_plot_leading:
        
        lda $72                 ; move to the previous cell
        sec
        sbc #8
        sta $72
        lda $73
        sbc #0
        sta $73
        clc
        
        lda $78                         ; Read the current type and the
        jsr read_right_sprite_address   ; corresponding right edge sprite.
        
        ldy #0
        lda ($76),y                     ; Load the type number, t,
        and #$1f                        ; mask off the top 3 bits,
        sta $78                         ; record the new current type.
        jsr read_left_sprite_address
        
        jsr plot_merged_tile_bank
        
        lda $74
        cmp #40
        bcc plot_bank2r_row_on_screen
        
        jmp plot_bank2r_offset_endloop   ; break if the screen edge is reached
        
        plot_bank2r_row_on_screen:
        
        lda $72                 ; move to the next cell
        adc #8
        sta $72
        lda $73
        adc #0
        sta $73
        clc
        
        plot_bank2r_row_loop_skip_leading:
        clc
        
        plot_bank2r_offset_loop:
        
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$1f                    ; mask off the top 3 bits,
            sta $78                     ; store the current type.
            
            ldy #1
            lda ($76),y                 ; Load the number of tiles minus 1, n - 1.
            sta $79                     ; temp (n - 1)
            cmp #0                      ; If there is only one tile in the
            beq plot_bank2r_offset_next  ; span, move to the next span,
                                        ; otherwise plot a continuation tile.
            
            lda $78
            jsr read_rotated_sprite_address
            
            jsr plot_tile_bank
            
            lda $74
            adc $79                 ; Add n - 1 to o.
            clc
            
            cmp #40                         ; Break if the screen edge is reached.
            bcs plot_bank2r_offset_endloop
            sta $74                         ; Store the new offset
            
            lda $79                 ; n - 1
            asl
            asl
            asl                     ; (n - 1)*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73                 ; x ($72,$73)
            clc
            
            plot_bank2r_offset_next:
            clc
            
            lda $76                 ; Add 2 to I.
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            lda $78                         ; Read the current type and the
            jsr read_right_sprite_address   ; corresponding right edge sprite.
            
            ldy #0
            lda ($76),y                     ; Load the type number, t,
            and #$1f                        ; mask off the top 3 bits,
            sta $78                         ; record the new current type.
            jsr read_left_sprite_address
            
            jsr plot_merged_tile_bank
            
            lda $72                 ; move to the next cell
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc
            
            inc $74
            
            lda $74
            cmp #40
            bcs plot_bank2r_offset_endloop   ; break if the screen edge is reached

            jmp plot_bank2r_offset_loop
        
        plot_bank2r_offset_endloop:
        clc
        
        dex
        bmi plot_bank2r_row_endloop
        jmp plot_bank2r_row_loop
    
    plot_bank2r_row_endloop:
    clc
    rts

plot_bank2l:

    ldx #15          ; row number
    
    plot_bank2l_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.
        cmp #42
        bcc plot_bank2l_row_loop_calculate_row_address
        
            dex
            bpl plot_bank2l_row_loop
            clc
            rts
        
        plot_bank2l_row_loop_calculate_row_address:
        sta $74
        
        lda initial_row_tiles,x         ; Load the initial tile type,
        and #$1f                        ; mask off the top 3 bits.
        sta $78
        
        lda $74
        cmp #2                              ; Both the trailing tile and the
        bcc plot_bank2l_skip_leading_tile   ; merged tile can be plotted.
        
            jsr read_screen_address_bank2   ; $72,$73
            
            lda $72
            sec
            sbc #16
            sta $72
            lda $73
            sbc #0
            sta $73
            clc
            
            lda $78
            jsr read_rotated_sprite_address ; $70,$71
            jsr plot_tile_bank
            
            inc $74     ; Move to the next cell, referring to any following
                        ; merged tile.
            lda $74
            cmp #42
            bcc plot_bank2l_leading_next
            
                clc                     ; at the end of the row, move to the next row
                dex                     ; if possible
                bpl plot_bank2l_row_loop
            
                clc                     ; otherwise exit
                rts
        
            plot_bank2l_leading_next:
            
                lda $72                 ; move to the next cell
                adc #8
                sta $72
                lda $73
                adc #0
                sta $73
                clc
                
                jmp plot_bank2l_offset_loop ; Jump to the loop so that the span
                                            ; can be plotted.
        plot_bank2l_skip_leading_tile:
        
        cmp #1
        bne plot_bank2l_skip_leading_merged_tile
        
            clc                     ; Only the merged tile can be plotted.
        
            lda bank2_rows_low,x    ; Use the screen start address for the
            sta $72                 ; row, R, to get x.
            lda bank2_rows_high,x
            sta $73                 ; x ($72,$73)
            clc
            
            inc $74
            
            jmp plot_bank2l_offset_loop     ; Jump to the loop so that the span
                                            ; can be plotted.
        
        plot_bank2l_skip_leading_merged_tile:
        
        clc ; The initial offset is 0, meaning that neither the trailing tile
            ; nor the merged tile can be plotted.
        
            lda bank2_rows_low,x    ; Use the screen start address for the
            sta $72                 ; row, R, to get x.
            lda bank2_rows_high,x
            sta $73                 ; x ($72,$73)
            clc
            
            lda $72     ; The merged tile would be plotted off the left hand
            sec         ; side of the screen.
            sbc #8
            sta $72
            lda $73
            sbc #0
            sta $73
            clc
            
            inc $74
            
            jmp plot_bank2l_offset_loop_span
        
        plot_bank2l_offset_loop:
        
            lda $78                         ; Read the current type and the
            jsr read_right_sprite_address   ; corresponding right edge sprite.
            
            ldy #0
            lda ($76),y                     ; Load the type number, t,
            and #$1f                        ; mask off the top 3 bits,
            sta $78                         ; record the new current type.
            jsr read_left_sprite_address
            
            jsr plot_merged_tile_bank
            
            lda $74
            cmp #41
            bcs plot_bank2l_offset_endloop   ; break if the screen edge is reached
            
            jmp plot_bank2l_offset_loop_span_continue
            
            plot_bank2l_offset_loop_span:
            
                ldy #0          ; Keep the previous type updated (only need to
                lda ($76),y     ; do this if the merged tile was not plotted).
                and #$1f        ; Mask off the top 3 bits,
                sta $78         ; Record the new current type.
            
            plot_bank2l_offset_loop_span_continue:
            
            ldy #1
            lda ($76),y                 ; Load the number of tiles minus 1, n - 1.
            sta $79                     ; temp (n - 1)
            cmp #0                      ; If there is only one tile in the
            beq plot_bank2l_offset_next ; span, move to the next span,
                                        ; otherwise plot a trailing tile.
            clc
            lda $74
            adc $79                 ; Add n - 1 to o.
            clc
            
            cmp #42                     ; Break if the screen edge is reached.
            bcs plot_bank2l_offset_endloop
            sta $74                     ; Store the new offset.
            
            lda $79                 ; n - 1
            asl
            asl
            asl                     ; (n - 1)*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73                 ; x ($72,$73)
            clc
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$1f                    ; mask off the top 3 bits,
            sta $78                     ; store the current type.
            jsr read_rotated_sprite_address
            
            jsr plot_tile_bank
            
            plot_bank2l_offset_next:
            
            inc $74
            
            lda $74                 ; Break if the screen edge is reached.
            cmp #42
            bcs plot_bank2l_offset_endloop
            
            lda $72                 ; Move to the next cell.
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc
            
            lda $76                 ; Add 2 to I.
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            jmp plot_bank2l_offset_loop
        
        plot_bank2l_offset_endloop:
        clc
        
        dex
        bmi plot_bank2l_row_endloop
        jmp plot_bank2l_row_loop
    
    plot_bank2l_row_endloop:
    clc
    rts

read_row_address:           ; X=row number
                            ; Returns $76,$77 (row address)

    lda row_table_low,x     ; Load entry a from the table.
    sta $76
    lda row_table_high,x
    sta $77

    lda row_indices,x   ; Load index i from the indices;
    asl                 ; and multiply it by 2 to get i*2.
    adc $76             ; Add i*2 to A to get the address, I, of the
    sta $76             ; starting offset and type.
    lda $77
    adc #0
    sta $77
    clc
    
    rts

initial_plot_bank1:

    ldx #15
    initial_plot_bank1_row_loop:
    
        clc
        jsr read_row_address    ; sets $76,$77
        
        lda bank1_rows_low,x
        sta $72
        lda bank1_rows_high,x
        sta $73                 ; x ($72,$73)
        
        lda #0
        sta $74
        
        lda initial_row_offsets,x
        cmp #0
        beq initial_plot_bank1_span_loop
        sta $78
        dec $78
        
        lda initial_row_tiles,x
        and #$1f                    ; Mask off the top 3 bits.
        jsr read_sprite_address
        
        jsr initial_plot_bank1_tile_loop
        
        lda $74
        cmp #40
        bcs initial_plot_bank1_span_endloop
        
        initial_plot_bank1_span_loop:
        
            ldy #0
            lda ($76),y             ; Load the type number, t,
            and #$1f                ; mask off the top 3 bits,
            jsr read_sprite_address
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            sta $78
            
            jsr initial_plot_bank1_tile_loop
            
            lda $74
            cmp #40
            beq initial_plot_bank1_span_endloop
            clc
            
            lda $76
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            jmp initial_plot_bank1_span_loop
        
        initial_plot_bank1_span_endloop:
        clc
        
        dex
        bpl initial_plot_bank1_row_loop
    
    clc
    rts

initial_plot_bank1_tile_loop:   ; $74=column
                                ; $76,$77=span address
                                ; $78=number of tiles

    jsr plot_tile_bank

    lda $72
    adc #8
    sta $72
    lda $73
    adc #0
    sta $73
    clc

    inc $74         ; one tile filled on the screen

    lda $74
    cmp #40
    beq initial_plot_bank1_span_endloop
    lda $78
    cmp #0
    beq initial_plot_bank1_tile_endloop

    dec $78         ; one tile less to plot

    jmp initial_plot_bank1_tile_loop

    initial_plot_bank1_tile_endloop:
    clc
    rts

initial_plot_bank2:

    ldx #15
    initial_plot_bank2_row_loop:
    
        clc
        jsr read_row_address
        
        lda bank2_rows_low,x
        sta $72
        lda bank2_rows_high,x
        sta $73                 ; x ($72,$73)
        
        lda #0
        sta $74
        
        lda initial_row_offsets,x
        cmp #0
        beq initial_plot_bank2_span_loop
        sta $78
        dec $78
        
        lda initial_row_tiles,x         ; Load the initial tile type,
        and #$1f                        ; mask off the top 3 bits.
        sta $79
        jsr read_rotated_sprite_address
        
        jsr initial_plot_bank2_tile_loop
        
        lda $74
        cmp #40
        bcs initial_plot_bank2_span_endloop
        
        initial_plot_bank2_span_loop:
        
            lda $74
            cmp #0
            beq initial_plot_bank2_span_loop_skip_merged
            
            lda $79                         ; Read the current type and the
            jsr read_right_sprite_address   ; corresponding right edge sprite.
            
            ldy #0
            lda ($76),y                     ; Load the type number, t,
            and #$1f                        ; mask off the top 3 bits,
            sta $79                         ; record the new current type.
            jsr read_left_sprite_address
            
            jsr plot_merged_tile_bank
            
            lda $72
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc
            
            inc $74         ; one tile filled on the screen
            
            initial_plot_bank2_span_loop_skip_merged:
            
            ldy #0
            lda ($76),y                     ; Load the type number, t,
            and #$1f                        ; mask off the top 3 bits,
            sta $79                         ; record the new current type.
            jsr read_rotated_sprite_address
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            sta $78
            
            jsr initial_plot_bank2_tile_loop
            
            lda $74
            cmp #40
            beq initial_plot_bank2_span_endloop
            clc
            
            lda $76
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            jmp initial_plot_bank2_span_loop
        
        initial_plot_bank2_span_endloop:
        clc
        
        dex
        bmi initial_plot_bank2_row_endloop
        jmp initial_plot_bank2_row_loop
    
    initial_plot_bank2_row_endloop:
    clc
    rts

initial_plot_bank2_tile_loop:

    lda $74
    cmp #40
    beq initial_plot_bank2_span_endloop
    lda $78
    cmp #0
    beq initial_plot_bank2_tile_endloop
    
    jsr plot_tile_bank
    
    lda $72
    adc #8
    sta $72
    lda $73
    adc #0
    sta $73
    clc
    
    inc $74         ; one tile filled on the screen
    dec $78         ; one tile less to plot
    
    jmp initial_plot_bank2_tile_loop

    initial_plot_bank2_tile_endloop:
    clc
    rts

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c

plot8x24_y0:            ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #2

    plot8x24_y0_loop:

        ldy #15

        plotloop8x24_y0_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y0_0

        dex
        bmi plot8x24_y0_exit
        
        lda $72
        adc #$40
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        lda $70
        adc #16
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        jmp plot8x24_y0_loop

    plot8x24_y0_exit:
    clc
    rts

player_sprites_low:  .byte <char_area, <[char_area + 48], <[char_area + 96], <[char_area + 144]
player_sprites_high: .byte >char_area, >[char_area + 48], >[char_area + 96], >[char_area + 144]

plot_char_bank1:            ; plots the player character on bank 1

    ldx player_animation
    lda player_sprites_low,x
    sta $70
    lda player_sprites_high,x
    sta $71
    
    ldx player_y
    lda player_x
    asl
    asl
    asl
    adc bank1_rows_low,x
    sta $72
    lda bank1_rows_high,x
    adc #0
    sta $73
    clc
    
    jmp plot8x24_y0
    
plot_char_bank2:            ; plots the player character on bank 2

    ldx player_animation
    lda player_sprites_low,x
    sta $70
    lda player_sprites_high,x
    sta $71
    
    ldx player_y
    lda player_x
    asl
    asl
    asl
    adc bank2_rows_low,x
    sta $72
    lda bank2_rows_high,x
    adc #0
    sta $73
    clc
    
    jmp plot8x24_y0

plot_player:

    lda bank_number
    cmp #1
    bne plot_player_plot_bank2
    
        clc
        jmp plot_char_bank1
    
    plot_player_plot_bank2:
    
        clc
        jmp plot_char_bank2

check_tile:         ; $70=x position (0-39)
                    ; $71=y position (0-15)

    ldx $71
    jsr read_row_address
    
    lda initial_row_offsets,x
    cmp $70
    beq check_tile_spans
    bcc check_tile_spans
    
    clc
    lda initial_row_tiles,x
    rts                     ; Return the type.
    
    check_tile_spans:
    clc
    
    sta $74                 ; Store the row offset of the next span.
    
    check_tile_spans_loop:
    
        ldy #1
        lda ($76),y         ; Load the number of tiles minus 1, n - 1.
        adc #1              ; n
        bcs check_tile_spans_loop_found
        adc $74             ; Add to the row offset
        bcs check_tile_spans_loop_found
        
        cmp $70
        beq check_tile_spans_loop_next
        bcc check_tile_spans_loop_next
        
        check_tile_spans_loop_found:
        
        clc
        ldy #0
        lda ($76),y             ; Load the type number, t,
        rts                     ; Return the type number in A, leaving $76,$77
                                ; pointing to the span that was found.
        
        check_tile_spans_loop_next:
        
        cmp #40
        bpl check_tile_spans_endloop
        
        sta $74             ; and store the result.
        
        lda $76             ; Increment the row address.
        adc #2
        sta $76
        lda $77
        adc #0
        sta $77
        clc
        
        jmp check_tile_spans_loop
        
    check_tile_spans_endloop:
    clc
    
    lda #0          ; In theory, we should never reach here.
    rts

check_move_right:

    lda bank_number
    cmp #2
    bne check_move_right_continue
    
    clc             ; If bank 2 is showing, we can move right without checking.
    rts
    
    check_move_right_continue:
    clc
    
    lda player_x
    adc #2
    sta $70
    lda player_y
    sta $71
    clc
    
    jmp check_move  ; branch then exit

player_move_right:

    clc
    jsr check_move_right
    bcs player_move_right_cannot_move
    
    jmp scroll_right_update     ; branch then exit
    
    player_move_right_cannot_move:
    
    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

check_move_left:

    lda bank_number
    cmp #2
    bne check_move_left_continue
    
    clc             ; If bank 2 is showing, we can move left without checking.
    rts
    
    check_move_left_continue:
    clc
    
    lda player_x
    sec
    sbc #1
    sta $70
    clc
    lda player_y
    sta $71
    
    ; fall through into the next routine

check_move:

    lda #2
    sta $72
    
    lda player_falling
    cmp #0
    beq check_move_loop
    
    inc $72         ; If the player is falling then we need to check an
                    ; additional tile.
    
    check_move_loop:
    
        clc
        jsr check_tile
        cmp #0
        beq check_move_next
        sec
        rts
        
        check_move_next:
        
        inc $71
        dec $72
        bpl check_move_loop
    
    clc
    rts

player_move_left:

    clc
    jsr check_move_left
    bcs player_move_left_cannot_move
    
    jmp scroll_left_update     ; branch then exit
    
    player_move_left_cannot_move:
    
    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

jump_steps: .byte 2,1,1,0
char_plot_routines: .byte 0,0,<plot_char_bank1,>plot_char_bank1,<plot_char_bank2,>plot_char_bank2

player_jump:

    clc
    
    ldx player_jumping      ; Load the number of rows to move.
    lda jump_steps,x
    sta $72
    
    lda player_y
    sta $71
    
    player_jump_check_loop:
    
        lda $72         ; If there are no more rows to move then stop jumping.
        cmp #0
        beq player_jump_check_endloop
        
        lda $71                         ; If the character reaches the top of
        cmp #0                          ; the screen then stop jumping.
        beq player_jump_stop_jumping
        dec $71
        clc
        
        lda player_x
        sta $70
        jsr check_tile
        cmp #0
        bne player_jump_stop_jumping
        clc
        
        inc $70
        
        jsr check_tile
        cmp #0
        bne player_jump_stop_jumping
        clc
        
        lda bank_number         ; When half way across a cell, check another cell
        cmp #2                  ; above the player since they could be under one
        bne player_jump_move_up ; or more of three tiles.
        clc
        
            inc $70
            
            jsr check_tile
            cmp #0
            bne player_jump_stop_jumping
        
        player_jump_move_up:
        
            lda $71
            sta player_y
        
            dec $72
            jmp player_jump_check_loop
    
    player_jump_check_endloop:
    clc
    
    lda player_jumping
    adc #1
    cmp #4
    bpl player_jump_stop_jumping
    
    sta player_jumping
    clc
    rts
    
    player_jump_stop_jumping:
    clc
    
    lda #0
    sta player_jumping
    
    clc
    rts

read_screen_address_bank1:  ; X=row, A=column offset
                            ; sets $72,$73

    asl                     ; Multiply o by 8
    asl
    asl
    sta $72
    lda #0
    adc #0
    sta $73
    clc
    
    lda $72
    adc bank1_rows_low,x    ; Add to the screen start address for the
    sta $72                 ; row, R, to get x.
    lda $73
    adc bank1_rows_high,x
    sta $73                 ; x ($72,$73)
    clc
    
    rts

read_screen_address_bank2:  ; X=row, A=column offset
                            ; sets $72,$73=screen address

    asl                     ; Multiply o by 8
    asl
    asl
    sta $72
    lda #0
    adc #0
    sta $73
    clc
    
    lda $72
    adc bank2_rows_low,x    ; Add to the screen start address for the
    sta $72                 ; row, R, to get x.
    lda $73
    adc bank2_rows_high,x
    sta $73                 ; x ($72,$73)
    clc
    
    rts

read_sprite_address:        ; $76,$77=span address
                            ; sets $70,$71=sprite address

    asl                     ; multiply by 8 to get t1.
    asl
    asl
    adc #sprite_area_low    ; add to S to get S1.
    sta $70
    lda #sprite_area_high
    adc #0
    sta $71                 ; S1 ($70,$71)
    clc
    rts

read_left_sprite_address:       ; A=tile number in high 4 bits
                                ; sets $70,$71=sprite address

    asl                         ; multiply by 8
    asl
    asl
    adc #left_sprites_low       ; add to S to get S2.
    sta $70
    lda #left_sprites_high
    adc #0
    sta $71                     ; S2 ($70,$71)
    clc
    
    rts

read_rotated_sprite_address:    ; A=tile number
                                ; sets $70,$71=sprite address

    asl                     ; multiply by 8 to get t1.
    asl
    asl
    adc #rotated_sprites_low    ; add to S to get S1.
    sta $70
    lda #rotated_sprites_high
    adc #0
    sta $71                 ; S1 ($70,$71)
    clc
    
    rts

read_right_sprite_address:      ; A=tile number in high 4 bits
                                ; sets $80,$81=sprite address

    asl                         ; multiply by 8
    asl
    asl
    adc #right_sprites_low      ; add to S to get S2.
    sta $80
    lda #right_sprites_high
    adc #0
    sta $81                     ; S2 ($80,$81)
    clc
    
    rts

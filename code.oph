; Copyright (C) 2013 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $0e00

.include "constants.oph"

.alias scrolled                         $7f
.alias scroll_offset_low                $8e
.alias scroll_offset_high               $8f

; Declare these here to make it easy to see that they are being used.
.alias tile_visibility_table_low        $82
.alias tile_visibility_table_high       $83
.alias special_tile_numbers_table_low   $84
.alias special_tile_numbers_table_high  $85
.alias monster_positions_table_low      $86
.alias monster_positions_table_high     $87

; Each monster type is defined as yyyyynnd.
.alias monster_data_axis_bit            $01
.alias monster_data_type_bits           $06

; Each monster visible type is defined as nnxa.
.alias monster_animation_bit            $01
.alias monster_dx_bit                   $02
.alias monster_type_bits                $0c
.alias monster_plot_bits                $0f
.alias monster_direction_bit            $20
.alias monster_axis_bit                 $40
.alias monster_existence_bit            $80

.alias monster_horizontal_motion        $00
.alias monster_vertical_motion          $40

init:
    ; Set character's initial position and status.

    lda #19
    sta player_x
    lda #19
    sta player_y
    sta tracking_y      ; Set the vertical tracking position of the character.
    lda #0
    sta player_ys
    lda #2
    sta player_animation
    lda #0
    sta player_jumping
    sta player_moving
    sta player_falling
    lda #9
    sta player_lives
    lda #0
    sta player_lost

    ; Initialise the tile visibility values.

    ldx #31

    init_tile_visibility_loop:
        lda initial_tile_visibility_address,x
        sta tile_visibility_address,x
        dex
        bpl init_tile_visibility_loop
    clc

    lda #0              ; Use 0 and 1 for banks 1 and 2.
    sta bank_number

    ; Store table addresses in zero page locations for convenient access.
    lda #tile_visibility_low
    sta $82
    lda #tile_visibility_high
    sta $83

    lda #special_tile_numbers_low
    sta $84
    lda #special_tile_numbers_high
    sta $85

    lda #monster_positions_low
    sta $86
    lda #monster_positions_high
    sta $87

    ; Determine the left and right monster indices and offsets.

    lda #0
    sta monster_movement_counter

    ; Initialise the monster positions.

    ldx #15
    lda #0

    init_monster_positions_loop:
        sta monster_positions_address,x
        dex
        bpl init_monster_positions_loop

main:

    jsr clear_bank1
    jsr clear_bank2

    jsr init_scrolling

    jsr show_bank2          ; Hide the bank being plotted.
    jsr initial_plot_bank1
    jsr plot_char_bank1
    jsr plot_monsters_bank1 ; Show any initial monsters.
    jsr show_bank1          ; Show the completed bank.
    jsr initial_plot_bank2

    lda #0                  ; Set the initial scroll offset and tracking offset.
    sta scroll_offset_low
    sta tracking_low
    lda #0
    sta scroll_offset_high
    sta tracking_high

    main_loop:

        lda #0
        sta scrolled

        main_loop_check_lost:

        lda player_lost
        cmp #0
        beq main_loop_check_jump

            lda player_lives
            cmp #0
            beq main_loop_endloop

            jsr track_position      ; Move the player back to the tracking position.
            bcs main_loop_next

            lda #0
            sta player_lost

            lda tracking_y
            sta player_y

            jsr plot_char           ; Plot the character again.

        main_loop_check_jump:

        lda player_jumping
        cmp #0
        bne main_loop_check_fall

            jsr check_beneath

        main_loop_check_fall:

        lda player_falling
        cmp #0
        beq main_loop_allow_movement

            jsr player_fall
            bcs main_loop_next

        main_loop_allow_movement:

            clc

            jsr player_move
            jmp main_loop_next

        main_loop_next:

        lda scrolled
        cmp #0
        bne main_loop_after_monsters

        lda #19
        jsr $fff4
        jsr plot_monsters        ; unplot monsters
        jsr move_monsters
        jsr plot_monsters        ; plot monsters

        main_loop_after_monsters:
        clc

        inc monster_movement_counter
        clc

        ; --- Switch character test code (begin) ---
        ldx #157            ; (SPACE)
        jsr check_key
        cpy #255
        bne not_space

        clc
        jsr plot_char
        jsr switch_characters
        jsr plot_char

        not_space:
        ; --- Switch character test code (end) ---

        ldx #143            ; (Escape)
        jsr check_key
        cpy #255
        bne main_loop

    main_loop_endloop:

    clc
    rts

player_move:

    lda player_jumping
    cmp #0
    beq player_move_check_fall
    clc

    ; Whether moving or not, the player needs to be replotted before any
    ; scrolling occurs because the scrolling routine will replot the player.
    ; This needs to be optimised.

    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot

    jsr player_jump

    jsr plot_player                 ; plot

    lda player_moving
    cmp #1
    bne player_move_not_moving_left

    jsr player_move_left
    clc
    rts

    player_move_not_moving_left:
    cmp #2
    bne player_move_not_moving_right

    jsr player_move_right

    player_move_not_moving_right:

    clc
    rts

    player_move_check_fall:

    lda player_falling
    cmp #0
    beq player_move_check_keys

    clc
    rts

    player_move_check_keys:

    lda #0
    sta player_moving

    ldx #158        ; (Z)
    jsr check_key
    cpy #255
    bne player_move_not_left
    clc

    jsr player_move_left   ; allow the player to jump while moving

    lda #1                  ; 1=moving left
    sta player_moving

    jmp player_move_check_jump

    player_move_not_left:
    clc

    ldx #189        ; (X)
    jsr check_key
    cpy #255
    bne player_move_not_right
    clc

    jsr player_move_right   ; allow the player to jump while moving

    lda #2                  ; 2=moving right
    sta player_moving

    ; jmp player_move_check_jump (fall through)

    player_move_not_right:

    player_move_check_jump:

    lda player_jumping
    cmp #0
    bne player_move_not_jump

    ldx #182        ; (Return)
    jsr check_key
    cpy #255
    bne player_move_not_jump
    clc

    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot

    lda scroll_offset_low
    sta tracking_low
    lda scroll_offset_high
    sta tracking_high
    lda player_y
    sta tracking_y

    jsr player_jump

    jsr plot_player                 ; plot

    player_move_not_jump:

    clc
    rts

scroll_right_update:

    lda bank_number
    cmp #1              ; showing the second bank?
    beq scroll_right_update_show_bank1

    lda scroll_offset_low
    cmp #level_extent_low
    bne scroll_right_update_ok_to_scroll
    lda scroll_offset_high
    cmp #level_extent_high
    bne scroll_right_update_ok_to_scroll

    clc
    rts

    scroll_right_update_ok_to_scroll:
    clc

    lda #1
    sta scrolled

    jsr plot_bank2r
    lda #19
    jsr $fff4
    jsr show_bank2

    jsr scroll_update_bank1_bank2

    lda player_animation
    ora #$02
    sta player_animation

    jsr plot_char_bank2         ; plot the player on bank 2
    jsr scroll_monsters_right
    jsr plot_monsters_bank2     ; plot the monsters, too

    clc
    rts

    scroll_right_update_show_bank1:
    clc

    lda #1
    sta scrolled

    lda scroll_offset_low   ; Increase the scroll offset before showing bank 1.
    adc #1
    sta scroll_offset_low
    lda scroll_offset_high
    adc #0
    sta scroll_offset_high
    clc

    jsr scroll_right

    jsr plot_bank1r
    lda #19
    jsr $fff4
    jsr show_bank1

    jsr scroll_update_bank2_bank1

    jsr scroll_right_update_monsters

    lda player_animation
    ora #$02
    sta player_animation

    jsr plot_char_bank1         ; plot the player on bank 1
    jsr scroll_monsters_right
    jsr plot_monsters_bank1     ; plot the monsters, too

    clc
    rts

scroll_left_update:

    lda bank_number
    cmp #1              ; showing the second bank?
    beq scroll_left_update_show_bank1

    lda scroll_offset_low
    cmp #0
    bne scroll_left_update_ok_to_scroll
    lda scroll_offset_high
    cmp #0
    bne scroll_left_update_ok_to_scroll

    clc
    rts

    scroll_left_update_ok_to_scroll:
    clc

    lda #1
    sta scrolled

    jsr scroll_left

    jsr plot_bank2l
    lda #19
    jsr $fff4
    jsr show_bank2

    jsr scroll_update_bank1_bank2

    jsr scroll_left_update_monsters

    lda player_animation
    and #$01
    sta player_animation

    jsr plot_char_bank2         ; plot the player on bank 2
    jsr scroll_monsters_left
    jsr plot_monsters_bank2     ; plot the monsters, too

    lda scroll_offset_low   ; Decrease the scroll offset after showing bank 2.
    sec
    sbc #1
    sta scroll_offset_low
    lda scroll_offset_high
    sbc #0
    sta scroll_offset_high
    clc

    clc
    rts

    scroll_left_update_show_bank1:
    clc

    lda #1
    sta scrolled

    jsr plot_bank1l
    lda #19
    jsr $fff4
    jsr show_bank1

    jsr scroll_update_bank2_bank1

    lda player_animation
    and #$01
    sta player_animation

    jsr plot_char_bank1         ; plot the player on bank 1
    jsr scroll_monsters_left
    jsr plot_monsters_bank1     ; plot the monsters, too

    clc
    rts

scroll_update_bank2_bank1:

    jsr plot_char_bank2         ; unplot the player on bank 2
    jsr plot_monsters_bank2     ; unplot the monsters, too

    lda player_falling
    cmp #0
    beq scroll_update_plot_bank1

    jsr player_drop
    jmp scroll_update_animation_next

    scroll_update_plot_bank1:

    lda player_jumping
    cmp #0
    bne scroll_update_animation_next

    lda player_animation
    eor #1
    sta player_animation

    scroll_update_animation_next:
    clc

    lda #0
    sta bank_number

    clc
    rts

scroll_update_bank1_bank2:

    jsr plot_char_bank1         ; unplot the player on bank 1
    jsr plot_monsters_bank1     ; unplot the monsters, too

    lda player_falling
    cmp #0
    beq scroll_update_plot_bank2

    jsr player_drop

    scroll_update_plot_bank2:
    clc

    lda #1
    sta bank_number

    clc
    rts

check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jmp $fff4   ; Return directly from the OS routine.

check_beneath:

    lda player_y
    cmp #21
    bcs check_beneath_demise_exit

    adc #3
    sta $81
    lda player_x
    sta $80

    jsr check_tile
    bcs check_beneath_exit

    inc $80
    jsr check_tile
    bcs check_beneath_exit

    lda bank_number         ; When half way across a cell, check another cell
    cmp #1                  ; beneath the player since they could be standing
    bne check_beneath_fall  ; on one or more of three tiles.

    clc
    inc $80
    jsr check_tile
    bcs check_beneath_exit

    check_beneath_fall:

    lda player_falling
    cmp #0
        bne check_beneath_fall_exit

    lda #1
    sta player_falling

    check_beneath_fall_exit:
    clc
    rts

    check_beneath_demise_exit:

    jsr plot_char       ; Unplot the character.

    lda #1
    sta player_lost
    dec player_lives

    check_beneath_exit:
    clc

    lda #0
    sta player_falling
    rts

clear_bank1:

    lda #$00
    sta $70
    lda #$35
    sta $71
    ldy #0

    clear_bank1_loop:

        lda #0
        sta ($70),y

        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        cmp #$58
        bne clear_bank1_loop

    clc
    rts

clear_bank2:

    lda #$00
    sta $70
    lda #$5d
    sta $71
    ldy #0

    clear_bank2_loop:

        lda #0
        sta ($70),y

        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        cmp #$80
        bne clear_bank2_loop

    clc
    rts

show_bank1:

    lda #$00
    sta $fe02
    lda #$18
    sta $fe03
    clc
    rts

show_bank2:

    lda #$00
    sta $fe02
    lda #$2c
    sta $fe03
    clc
    rts

bank1_char_rows_low:  .byte $40,$80,$c0,$00,$40,$80,$c0,$00
bank1_rows_low:  .byte  $40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00
bank1_char_rows_high: .byte $36,$37,$38,$3a,$3b,$3c,$3d,$3f
bank1_rows_high: .byte  $40,$41,$42,$44,$45,$46,$47,$49,$4a,$4b,$4c,$4e,$4f,$50,$51,$53
bank2_char_rows_low:  .byte $40,$80,$c0,$00,$40,$80,$c0,$00
bank2_rows_low:  .byte  $40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00
bank2_char_rows_high: .byte $5e,$5f,$60,$62,$63,$64,$65,$67
bank2_rows_high: .byte  $68,$69,$6a,$6c,$6d,$6e,$6f,$71,$72,$73,$74,$76,$77,$78,$79,$7b

init_scrolling:

    ldx #15
    init_scrolling_loop:

        lda #0
        sta row_indices,x
        sta initial_row_tiles,x
        sta initial_row_offsets,x
        sta max_row_offsets,x
        dex
        bpl init_scrolling_loop

    ; Initialise the monster indices and offsets.

    ; Initialise the on-screen monster indices.
    ; Usually, the left index trails the right index by the number of monsters
    ; that appear on screen. If an empty span appears, it is usually 256 cells
    ; long so the contents of the table are not critical. However, the first
    ; span is empty and short, so this ensures that the indices are
    ; synchronised after it appears.
    sta visible_monster_left_index
    lda #4
    sta visible_monster_right_index

    ; The left index and offset are straightforward to set because they are at
    ; the start of the level, so we store zero in both of them. A padding span
    ; ensures that monsters will be created before they appear on the left hand
    ; side of the screen.
    lda #0
    sta monster_left_index
    sta monster_left_offset
    sta monster_left_max_offset

    ; The right index and offset need to be calculated from the start of the
    ; level, starting from the span after the empty padding span.
    lda #2
    sta monster_right_index         ; Record the initial right edge index.
    lda #0
    sta $8d                         ; Keep track of the current column number.

    lda #1
    jsr read_monster_row_address    ; Examine the monster data at index 1.

    ldy #1                          ; Examine the span information.

    init_scrolling_monster_loop:

        lda ($76),y                     ; Load the span length (n - 1).
        cmp #40                         ; If this alone exceeds the screen
        bcs init_scrolling_monster_next ; width then calculate the offset.

        adc $8d                         ; Calculate the next monster position.
        adc #1

        cmp #41                         ; Continue until we reach the right
        bcs init_scrolling_monster_next ; edge of the screen.

        sta $8d                     ; Store the new monster position.

        inc monster_right_index     ; Update the index until we reach the edge.
        lda $76
        adc #2
        sta $76
        lda $77
        adc #0
        sta $77
        clc
        jmp init_scrolling_monster_loop

    init_scrolling_monster_next:
    clc

    ; The right index is already set. Calculate the offset from the current
    ; column value.
    lda ($76),y
    sta monster_right_max_offset    ; Store the maximum offset.

    sec                             ; Calculate the remaining offset until the
    sbc #39                         ; start of the next span.
    clc
    adc $8d                         ; Since the position is less than 39, the
    sta monster_right_offset        ; carry flag should not be set here.

    rts

plot_bank1r:

    ldx #15          ; row number

    plot_bank1r_row_loop:

        clc
        jsr read_row_address

        lda initial_row_offsets,x   ; Load the initial row offset, o.

        cmp #40
        bcc plot_bank1r_row_loop_calculate_row_address

        dex
        bpl plot_bank1r_row_loop     ; Loop again or exit.
        clc
        rts

        plot_bank1r_row_loop_calculate_row_address:

        sta $74
        jsr read_screen_address_bank1

        plot_bank1r_offset_loop:

            ldy #0
            lda ($76),y             ; Load the type number, t,
            jsr read_sprite_address
            jsr plot_tile_bank

            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            adc #1              ; n
            bcs plot_bank1r_offset_endloop

            tay                 ; temp (n)
            adc $74             ; Add n to o.
            bcs plot_bank1r_offset_endloop

            cmp #40
            bcs plot_bank1r_offset_endloop
            sta $74

            tya                 ; temp (n)
            asl
            asl
            asl                 ; n*8
            sta $8c
            lda #0
            adc #0
            sta $8d
            clc

            lda $72
            adc $8c
            sta $72
            lda $73
            adc $8d
            sta $73             ; x ($72,$73)
            clc

            lda $76             ; Add 2 to I.
            adc #2
            sta $76
            bcc plot_bank1r_offset_loop

            lda $77
            adc #0
            sta $77
            clc

            jmp plot_bank1r_offset_loop

        plot_bank1r_offset_endloop:
        clc

        dex
        bmi plot_bank1r_row_endloop
        jmp plot_bank1r_row_loop

    plot_bank1r_row_endloop:
    clc
    rts

plot_bank1l:

    ldx #15          ; row number

    plot_bank1l_row_loop:

        clc
        jsr read_row_address

        lda initial_row_offsets,x   ; Load the initial row offset, o.

        cmp #41
        bcc plot_bank1l_row_loop_calculate_row_address

        dex
        bpl plot_bank1l_row_loop     ; Loop again or exit.
        clc
        rts

        plot_bank1l_row_loop_calculate_row_address:
        sta $74

        cmp #0
        beq plot_bank1l_skip_leading_tile

            clc
            jsr read_screen_address_bank1

            lda $72
            sec
            sbc #8
            sta $72
            lda $73
            sbc #0
            sta $73
            clc

            lda initial_row_tiles,x     ; Load the initial tile type.
            jsr read_sprite_address

            jmp plot_bank1l_offset_loop

        plot_bank1l_skip_leading_tile:
        clc

            lda bank1_rows_low,x    ; Use the screen start address for the
            sta $72                 ; row, R, to get x.
            lda bank1_rows_high,x
            sta $73                 ; x ($72,$73)
            clc

            lda $72     ; The leading tile would be plotted off the left hand
            sec         ; side of the screen.
            sbc #8
            sta $72
            lda $73
            sbc #0
            sta $73
            clc

            jmp plot_bank1l_offset_loop_span

        plot_bank1l_offset_loop:

            jsr plot_tile_bank

            plot_bank1l_offset_loop_span:

            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            adc #1
            bcs plot_bank1l_offset_endloop

            tay                 ; temp (n)
            adc $74             ; Add n to o.
            bcs plot_bank1l_offset_endloop

            cmp #41
            bcs plot_bank1l_offset_endloop
            sta $74

            tya                 ; temp (n)
            asl
            asl
            asl                 ; n*8
            sta $8c
            lda #0
            adc #0
            sta $8d
            clc

            lda $72
            adc $8c
            sta $72
            lda $73
            adc $8d
            sta $73             ; x ($72,$73)
            clc

            ldy #0
            lda ($76),y             ; Load the type number, t,
            jsr read_sprite_address

            lda $76             ; Add 2 to I.
            adc #2
            sta $76
            bcc plot_bank1l_offset_loop

            lda $77
            adc #0
            sta $77
            clc

            jmp plot_bank1l_offset_loop

        plot_bank1l_offset_endloop:
        clc

        dex
        bmi plot_bank1l_row_endloop
        jmp plot_bank1l_row_loop

    plot_bank1l_row_endloop:
    clc
    rts

plot_tile_bank:     ; $70,$71 source address
                    ; $72,$73 screen address

    ldy #7
    plot_tile_bank_loop:

        lda ($70),y
        sta ($72),y
        dey
        bpl plot_tile_bank_loop

    clc
    rts

plot_merged_tile_bank:  ; $70,$71 source address 1
                        ; $72,$73 screen address
                        ; $80,$81 source address 2

    ldy #7
    plot_merged_tile_bank_loop:

        lda ($70),y
        ora ($80),y
        sta ($72),y
        dey
        bpl plot_merged_tile_bank_loop

    clc
    rts

scroll_right:   ; Scroll the screen right by decreasing the initial row offsets
                ; until a new span needs to be shown. When this occurs, increase
                ; the row index, set the initial row tile to the type in the
                ; span that now starts off-screen, and set the initial row
                ; offset to the length of that span. The max
    ldx #15
    scroll_right_loop:

        lda initial_row_offsets,x
        cmp #0                              ; Is the current offset zero?
        beq scroll_right_loop_next_offset   ; If so, update the current span.

        dec initial_row_offsets,x   ; Otherwise, decrease the offset.
        dex
        bpl scroll_right_loop       ; Examine the next row.

        clc
        rts

        scroll_right_loop_next_offset:  ; Update the current span.
        clc

        jsr read_row_address    ; Read the row address before updating the index.

        inc row_indices,x       ; Increment the index to refer to the next span.

        ldy #0
        lda ($76),y             ; Load the tile type for the current span.
        sta initial_row_tiles,x ; Store the tile type.

        ldy #1                  ; Record the number of tiles left in the current
        lda ($76),y             ; span minus 1 (n - 1).
        sta initial_row_offsets,x
        sta max_row_offsets,x   ; This is also the span's maximum offset for
                                ; use when scrolling left.
        dex
        bpl scroll_right_loop

    clc
    rts

scroll_right_update_monsters:

    ; Update the indices and offsets into the monster data.

    dec monster_right_offset
    beq scroll_right_create_right_monster   ; Offset is zero - create a monster.
    lda monster_right_offset
    cmp #255
    bne scroll_right_handle_left_edge ; Offset is > 0, so check the left offset.

        ; The offset was zero, so it needs to be reset.
        ; Was:  v
        ;       M ...... m (current span = M; distance to M = 0)
        ; Now:   v
        ;       M ...... m (current span = m; distance to m = length of M)

        lda monster_right_index     ; Read the address of the right span.
        jsr read_monster_row_address

        ldy #1
        lda ($76),y                 ; The current span's length is used to count
        sta monster_right_offset    ; down to the next monster.
        sta monster_right_max_offset

        inc monster_right_index     ; Increment the right index to refer to the
                                    ; next span.

        jmp scroll_right_handle_left_edge

    scroll_right_create_right_monster:

        jsr create_monster_right

        lda visible_monster_right_index     ; Update the visible index to refer
        adc #4                              ; to the next slot in the monster
        and #$0c                            ; table after the monster has been
        sta visible_monster_right_index     ; created.
        clc

    scroll_right_handle_left_edge:

    dec monster_left_offset
    beq scroll_right_update_left_index ; Offset is zero - update on-screen index.
    lda monster_left_offset
    cmp #255
    bne scroll_right_update_monsters_exit   ; Offset is > 0, so exit.

        lda monster_left_index          ; Read the address of the current left
        jsr read_monster_row_address    ; span.

        ldy #1
        lda ($76),y                 ; The current span's length is used to count
        sta monster_left_offset     ; down to the next monster.
        sta monster_left_max_offset

        inc monster_left_index      ; Increment the left index to refer to the
                                    ; next span.
        clc
        rts

    scroll_right_update_left_index:

        clc

        lda visible_monster_left_index  ; Move the on-screen index back
        adc #4                          ; to its previous value.
        and #$0c
        sta visible_monster_left_index

    scroll_right_update_monsters_exit:
    clc
    rts

scroll_left:    ; Scroll the screen left by increasing the initial row offsets
                ; until a new span needs to be shown. When this occurs, decrease
                ; the row index, set the initial 
    ldx #15
    scroll_left_loop:

        lda initial_row_offsets,x
        cmp max_row_offsets,x                   ; Has the current offset reached
        beq scroll_left_loop_previous_offset    ; the maximum value?

        inc initial_row_offsets,x   ; If not, keep increasing the offset.
        dex
        bpl scroll_left_loop        ; Examine the next row.

        clc
        rts

        scroll_left_loop_previous_offset:   ; Update the current span.
        clc

        dec row_indices,x   ; Decrement the index to refer to the previous span.

        jsr read_row_address    ; Read the row address for the previous span.

        lda $76             ; Refer to the span before the previous span, p'.
        sec
        sbc #2
        sta $76
        lda $77
        sbc #0
        sta $77
        clc

        ldy #0
        lda ($76),y             ; Load the tile type for span p' and store it as
        sta initial_row_tiles,x ; the initial tile type.

        ldy #1                  ; Load the number of tiles in span p' minus 1
        lda ($76),y             ; (n - 1) and store this value as the maximum
        sta max_row_offsets,x   ; row offset for the previous span

        lda #0                      ; Set the initial row offset of the previous
        sta initial_row_offsets,x   ; span.

        dex
        bpl scroll_left_loop

    clc
    rts

scroll_left_update_monsters:

    ; Update the indices and offsets into the monster data.

    lda monster_right_offset
    cmp monster_right_max_offset            ; If the offset is at its maximum
    beq scroll_left_reset_right_offset      ; value then reset it.

        inc monster_right_offset            ; Otherwise, increase the offset.
        cmp #0                              ; If it was 0, we update the visible
        bne scroll_left_handle_left_edge    ; right index.

            sec
            lda visible_monster_right_index ; Move the on-screen index back
            sbc #4                          ; to its previous value.
            and #$0c
            sta visible_monster_right_index
            clc
            jmp scroll_left_handle_left_edge    ; Handle the left edge.

    scroll_left_reset_right_offset:

        ; The offset was at the maximum value, so it needs to be reset.
        ; Was:   v
        ;       M ...... m (current span = m; distance to m = maximum)
        ; Now:  v
        ;       M ...... m (current span = M; distance to M = 0)

        dec monster_right_index     ; Decrement the right index to refer to the
                                    ; previous span.

        lda #0                      ; The maximum offset was reached, so it
        sta monster_right_offset    ; needs to be reset. We retain the current
                                    ; index.

        ldx monster_right_index     ; Read the address of the new right span.
        dex
        txa
        jsr read_monster_row_address

        ldy #1
        lda ($76),y                     ; The new span's length is used to count
        sta monster_right_max_offset    ; up to the previous monster.

    scroll_left_handle_left_edge:

    lda monster_left_offset
    cmp monster_left_max_offset         ; If the offset is at its maximum value
    beq scroll_left_reset_left_offset   ; then reset it.

        inc monster_left_offset             ; Otherwise, increase the offset.
        cmp #0                              ; If it was 0, we create a monster.
        beq scroll_left_create_left_monster
        rts                                 ; Otherwise, exit.

    scroll_left_reset_left_offset:

        lda #0                  ; The maximum offset was reached, so it needs
        sta monster_left_offset ; to be reset.

        dec monster_left_index      ; Decrement the left index to refer to the
                                    ; previous span.

        ldx monster_left_index      ; Read the address of the new left span.
        dex
        txa
        jsr read_monster_row_address

        ldy #1
        lda ($76),y                 ; The new span's length is used to count
        sta monster_left_max_offset ; up to the previous monster.

        rts

    scroll_left_create_left_monster:

        lda visible_monster_left_index      ; Update the visible index to refer
        sec                                 ; to the previous slot in the
        sbc #4                              ; monster table before creating the
        and #$0c                            ; monster.
        sta visible_monster_left_index
        clc

        jsr create_monster_left

    clc
    rts

plot_bank2r:

    ldx #15          ; row number

    plot_bank2r_row_loop:

        clc
        jsr read_row_address

        lda initial_row_offsets,x   ; Load the initial row offset, o.
        cmp #41
        bcc plot_bank2r_row_loop_calculate_row_address

            dex
            bpl plot_bank2r_row_loop
            clc
            rts

        plot_bank2r_row_loop_calculate_row_address:

        sta $74
        jsr read_screen_address_bank2

        lda initial_row_tiles,x         ; Load the initial tile type,
        sta $78

        lda $74
        cmp #0
        beq plot_bank2r_row_loop_skip_leading
        cmp #41
        bcc plot_bank2r_row_loop_plot_leading

            dex
            bpl plot_bank2r_row_loop
            clc
            rts

        plot_bank2r_row_loop_plot_leading:

        lda $72                 ; move to the previous cell
        sec
        sbc #8
        sta $72
        lda $73
        sbc #0
        sta $73
        clc

        lda $78                         ; Read the current type and the
        jsr read_right_sprite_address   ; corresponding right edge sprite.

        ldy #0
        lda ($76),y                     ; Load the type number, t,
        sta $78                         ; record the new current type.
        jsr read_left_sprite_address

        jsr plot_merged_tile_bank

        lda $74
        cmp #40
        bcc plot_bank2r_row_on_screen

        jmp plot_bank2r_offset_endloop   ; break if the screen edge is reached

        plot_bank2r_row_on_screen:

        lda $72                 ; move to the next cell
        adc #8
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        plot_bank2r_row_loop_skip_leading:
        clc

        plot_bank2r_offset_loop:

            ldy #0
            lda ($76),y                 ; Load the type number, t,
            sta $78                     ; store the current type.

            ldy #1
            lda ($76),y                 ; Load the number of tiles minus 1, n - 1.
            sta $79                     ; temp (n - 1)
            cmp #0                      ; If there is only one tile in the
            beq plot_bank2r_offset_next  ; span, move to the next span,
                                        ; otherwise plot a continuation tile.

            lda $78
            jsr read_rotated_sprite_address

            jsr plot_tile_bank

            lda $74
            adc $79                 ; Add n - 1 to o.
            bcs plot_bank2r_offset_endloop

            cmp #40                         ; Break if the screen edge is reached.
            bcs plot_bank2r_offset_endloop
            sta $74                         ; Store the new offset

            lda $79                 ; n - 1
            asl
            asl
            asl                     ; (n - 1)*8
            sta $8c
            lda #0
            adc #0
            sta $8d
            clc

            lda $72
            adc $8c
            sta $72
            lda $73
            adc $8d
            sta $73                 ; x ($72,$73)
            clc

            plot_bank2r_offset_next:
            clc

            lda $76                 ; Add 2 to I.
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc

            lda $78                         ; Read the current type and the
            jsr read_right_sprite_address   ; corresponding right edge sprite.

            ldy #0
            lda ($76),y                     ; Load the type number, t,
            sta $78                         ; record the new current type.
            jsr read_left_sprite_address

            jsr plot_merged_tile_bank

            lda $72                 ; move to the next cell
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc

            inc $74

            lda $74
            cmp #40
            bcs plot_bank2r_offset_endloop   ; break if the screen edge is reached

            jmp plot_bank2r_offset_loop

        plot_bank2r_offset_endloop:
        clc

        dex
        bmi plot_bank2r_row_endloop
        jmp plot_bank2r_row_loop

    plot_bank2r_row_endloop:
    clc
    rts

plot_bank2l:

    ldx #15          ; row number

    plot_bank2l_row_loop:

        clc
        jsr read_row_address

        lda initial_row_offsets,x   ; Load the initial row offset, o.
        cmp #42
        bcc plot_bank2l_row_loop_calculate_row_address

            dex
            bpl plot_bank2l_row_loop
            clc
            rts

        plot_bank2l_row_loop_calculate_row_address:
        sta $74

        lda initial_row_tiles,x         ; Load the initial tile type,
        sta $78

        lda $74
        cmp #2                              ; Both the trailing tile and the
        bcc plot_bank2l_skip_leading_tile   ; merged tile can be plotted.

            jsr read_screen_address_bank2   ; $72,$73

            lda $72
            sec
            sbc #16
            sta $72
            lda $73
            sbc #0
            sta $73
            clc

            lda $78
            jsr read_rotated_sprite_address ; $70,$71
            jsr plot_tile_bank

            inc $74     ; Move to the next cell, referring to any following
                        ; merged tile.
            lda $74
            cmp #42
            bcc plot_bank2l_leading_next

                clc                     ; at the end of the row, move to the next row
                dex                     ; if possible
                bpl plot_bank2l_row_loop

                clc                     ; otherwise exit
                rts

            plot_bank2l_leading_next:

                lda $72                 ; move to the next cell
                adc #8
                sta $72
                lda $73
                adc #0
                sta $73
                clc

                jmp plot_bank2l_offset_loop ; Jump to the loop so that the span
                                            ; can be plotted.
        plot_bank2l_skip_leading_tile:

        cmp #1
        bne plot_bank2l_skip_leading_merged_tile

            clc                     ; Only the merged tile can be plotted.

            lda bank2_rows_low,x    ; Use the screen start address for the
            sta $72                 ; row, R, to get x.
            lda bank2_rows_high,x
            sta $73                 ; x ($72,$73)
            clc

            inc $74

            jmp plot_bank2l_offset_loop     ; Jump to the loop so that the span
                                            ; can be plotted.

        plot_bank2l_skip_leading_merged_tile:

        clc ; The initial offset is 0, meaning that neither the trailing tile
            ; nor the merged tile can be plotted.

            lda bank2_rows_low,x    ; Use the screen start address for the
            sta $72                 ; row, R, to get x.
            lda bank2_rows_high,x
            sta $73                 ; x ($72,$73)
            clc

            lda $72     ; The merged tile would be plotted off the left hand
            sec         ; side of the screen.
            sbc #8
            sta $72
            lda $73
            sbc #0
            sta $73
            clc

            inc $74

            jmp plot_bank2l_offset_loop_span

        plot_bank2l_offset_loop:

            lda $78                         ; Read the current type and the
            jsr read_right_sprite_address   ; corresponding right edge sprite.

            ldy #0
            lda ($76),y                     ; Load the type number, t,
            sta $78                         ; record the new current type.
            jsr read_left_sprite_address

            jsr plot_merged_tile_bank

            lda $74
            cmp #41
            bcs plot_bank2l_offset_endloop   ; break if the screen edge is reached

            jmp plot_bank2l_offset_loop_span_continue

            plot_bank2l_offset_loop_span:

                ldy #0          ; Keep the previous type updated (only need to
                lda ($76),y     ; do this if the merged tile was not plotted).
                sta $78         ; Record the new current type.

            plot_bank2l_offset_loop_span_continue:

            ldy #1
            lda ($76),y                 ; Load the number of tiles minus 1, n - 1.
            sta $79                     ; temp (n - 1)
            cmp #0                      ; If there is only one tile in the
            beq plot_bank2l_offset_next ; span, move to the next span,
                                        ; otherwise plot a trailing tile.
            clc
            lda $74
            adc $79                 ; Add n - 1 to o.
            bcs plot_bank2l_offset_endloop

            cmp #42                     ; Break if the screen edge is reached.
            bcs plot_bank2l_offset_endloop
            sta $74                     ; Store the new offset.

            lda $79                 ; n - 1
            asl
            asl
            asl                     ; (n - 1)*8
            sta $8c
            lda #0
            adc #0
            sta $8d
            clc

            lda $72
            adc $8c
            sta $72
            lda $73
            adc $8d
            sta $73                 ; x ($72,$73)
            clc

            ldy #0
            lda ($76),y                 ; Load the type number, t,
            sta $78                     ; store the current type.
            jsr read_rotated_sprite_address

            jsr plot_tile_bank

            plot_bank2l_offset_next:

            inc $74

            lda $74                 ; Break if the screen edge is reached.
            cmp #42
            bcs plot_bank2l_offset_endloop

            lda $72                 ; Move to the next cell.
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc

            lda $76                 ; Add 2 to I.
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc

            jmp plot_bank2l_offset_loop

        plot_bank2l_offset_endloop:
        clc

        dex
        bmi plot_bank2l_row_endloop
        jmp plot_bank2l_row_loop

    plot_bank2l_row_endloop:
    clc
    rts

read_row_address:           ; X=row number
                            ; Returns $76,$77 (row address)

    lda row_table_low,x     ; Load entry a from the table.
    sta $76
    lda row_table_high,x
    sta $77

    lda row_indices,x   ; Load index i from the indices;
    asl                 ; and multiply it by 2 to get i*2.
    adc $76             ; Add i*2 to A to get the address, I, of the
    sta $76             ; starting offset and type.
    lda $77
    adc #0
    sta $77
    clc

    rts

read_monster_row_address:   ; A=index
                            ; Returns $76,77 (monster row span address)
    clc
    asl                         ; index*2
    adc #<monster_row_address
    sta $76
    lda #>monster_row_address
    adc #0
    sta $77
    clc

    rts

initial_plot_bank1:

    ldx #15
    initial_plot_bank1_row_loop:

        clc
        jsr read_row_address    ; sets $76,$77

        lda bank1_rows_low,x
        sta $72
        lda bank1_rows_high,x
        sta $73                 ; x ($72,$73)

        lda #0
        sta $74

        lda initial_row_offsets,x
        cmp #0
        beq initial_plot_bank1_span_loop
        sta $78
        dec $78

        lda initial_row_tiles,x
        jsr read_sprite_address

        jsr initial_plot_bank1_tile_loop

        lda $74
        cmp #40
        bcs initial_plot_bank1_span_endloop

        initial_plot_bank1_span_loop:

            ldy #0
            lda ($76),y             ; Load the type number, t,
            jsr read_sprite_address

            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            sta $78

            jsr initial_plot_bank1_tile_loop

            lda $74
            cmp #40
            beq initial_plot_bank1_span_endloop
            clc

            lda $76
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc

            jmp initial_plot_bank1_span_loop

        initial_plot_bank1_span_endloop:

        dex
        bpl initial_plot_bank1_row_loop

    clc
    rts

initial_plot_bank1_tile_loop:   ; $74=column
                                ; $76,$77=span address
                                ; $78=number of tiles

    jsr plot_tile_bank

    lda $72
    adc #8
    sta $72
    lda $73
    adc #0
    sta $73
    clc

    inc $74         ; one tile filled on the screen

    lda $74
    cmp #40
    beq initial_plot_bank1_span_endloop
    lda $78
    cmp #0
    beq initial_plot_bank1_tile_endloop

    dec $78         ; one tile less to plot

    jmp initial_plot_bank1_tile_loop

    initial_plot_bank1_tile_endloop:
    clc
    rts

initial_plot_bank2:

    ldx #15
    initial_plot_bank2_row_loop:

        clc
        jsr read_row_address

        lda bank2_rows_low,x
        sta $72
        lda bank2_rows_high,x
        sta $73                 ; x ($72,$73)

        lda #0                  ; horizontal screen offset
        sta $74
        sta $79

        lda initial_row_offsets,x
        cmp #0                              ; If at the start of a span, just
        beq initial_plot_bank2_span_loop    ; go straight into the loop.
        sta $78                             ; Otherwise, store a decremented
        dec $78                             ; span length.

        lda initial_row_tiles,x             ; Use the current tile type for the
        sta $79                             ; span.
        jsr read_rotated_sprite_address

        jsr initial_plot_bank2_tile_loop

        lda $74
        cmp #40
        bcs initial_plot_bank2_span_endloop

        initial_plot_bank2_span_loop:

            lda $79                         ; Read the current type and the
            jsr read_right_sprite_address   ; corresponding right edge sprite.

            ldy #0
            lda ($76),y                     ; Load the type number, t,
            sta $79                         ; record the new current type.
            jsr read_left_sprite_address

            jsr plot_merged_tile_bank

            lda $72
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc

            inc $74         ; one tile filled on the screen

            initial_plot_bank2_span_loop_skip_merged:

            ldy #0
            lda ($76),y                     ; Load the type number, t,
            sta $79                         ; record the new current type.
            jsr read_rotated_sprite_address

            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            sta $78

            jsr initial_plot_bank2_tile_loop

            lda $74
            cmp #40
            beq initial_plot_bank2_span_endloop
            clc

            lda $76
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc

            jmp initial_plot_bank2_span_loop

        initial_plot_bank2_span_endloop:

        dex
        bmi initial_plot_bank2_row_endloop
        jmp initial_plot_bank2_row_loop

    initial_plot_bank2_row_endloop:
    clc
    rts

initial_plot_bank2_tile_loop:

    lda $74
    cmp #40
    beq initial_plot_bank2_span_endloop
    lda $78
    cmp #0
    beq initial_plot_bank2_tile_endloop

    jsr plot_tile_bank

    lda $72
    adc #8
    sta $72
    lda $73
    adc #0
    sta $73
    clc

    inc $74         ; one tile filled on the screen
    dec $78         ; one tile less to plot

    jmp initial_plot_bank2_tile_loop

    initial_plot_bank2_tile_endloop:
    clc
    rts

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c

plot8x24_y0:            ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #2

    plot8x24_y0_loop:

        ldy #15

        plotloop8x24_y0_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y0_0

        dex
        bmi plot8x24_y0_exit

        lda $72
        adc #$40
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        lda $70
        adc #16
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        jmp plot8x24_y0_loop

    plot8x24_y0_exit:
    clc
    rts

plot8x24_y1_data:   .byte 4, 12
plot_upper_offsets: .byte 0, 8, 16, 24
plot_lower_offsets: .byte 7, 15, 23, 31

plot8x24_y1:            ; $70,$71=source address
                        ; $72,$73=destination address

    lda #2
    sta $8d

    plot8x24_y1_loop:

        ldx #0
        plot8x24_y1_upper_loop_outer:

            ldy plot8x24_y1_data,x
            lda plot_upper_offsets,x
            sta $89

            plot8x24_y1_upper_loop_inner:       ; plot the first column until
                dey                             ; we reach the start
                cpy $89
                bmi plot8x24_y1_upper_loop_inner_endloop
                lda ($70),y
                eor ($72),y
                sta ($72),y
                jmp plot8x24_y1_upper_loop_inner

            plot8x24_y1_upper_loop_inner_endloop:
            clc

            inx
            cpx #2
            bne plot8x24_y1_upper_loop_outer

        clc
        lda $72       ; move the destination pointer to refer to the next line
        adc #$38
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        ldx #0
        plot8x24_y1_lower_loop_outer:

            lda plot_lower_offsets,x
            tay
            lda plot8x24_y1_data,x
            sta $89

            plot8x24_y1_lower_loop_inner:   ; plot until we reach the initial
                lda ($70),y                 ; offset for the column
                eor ($72),y
                sta ($72),y
                dey
                cpy $89
                bpl plot8x24_y1_lower_loop_inner

            inx
            cpx #2
            bne plot8x24_y1_lower_loop_outer

        dec $8d
        bmi plot8x24_y1_exit

        clc
        lda $70         ; update the source pointer to refer to the next piece
        adc #16         ; of sprite data
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; update the destination pointer to point to the next
        adc #8          ; space
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        jmp plot8x24_y1_loop

    plot8x24_y1_exit:
    clc
    rts

player_sprites_low:  .byte <player_left1, <player_left2, <player_right1, <player_right2
player_sprites_high: .byte >player_left1, >player_left2, >player_right1, >player_right2
player_y_offset:     .byte 0, 4

plot_char:

    lda bank_number
    cmp #0
    beq plot_char_bank1
    bne plot_char_bank2

plot_char_bank1:            ; plots the player character on bank 1

    lda player_lost
    cmp #0
    beq plot_char_bank1_continue
    rts

    plot_char_bank1_continue:
    ldx player_animation
    lda player_sprites_low,x
    sta $70
    lda player_sprites_high,x
    sta $71

    ldx player_y
    lda player_x
    asl
    asl
    asl
    adc bank1_char_rows_low,x
    sta $72
    lda bank1_char_rows_high,x
    adc #0
    sta $73
    clc

    lda player_ys
    cmp #1
    bne plot_char_bank1_y0
    clc
    lda $72
    adc #4
    sta $72
    jmp plot8x24_y1

    plot_char_bank1_y0:
    jmp plot8x24_y0

plot_char_bank2:            ; plots the player character on bank 2

    lda player_lost
    cmp #0
    beq plot_char_bank2_continue
    rts

    plot_char_bank2_continue:
    ldx player_animation
    lda player_sprites_low,x
    sta $70
    lda player_sprites_high,x
    sta $71

    ldx player_y
    lda player_x
    asl
    asl
    asl
    adc bank2_char_rows_low,x
    sta $72
    lda bank2_char_rows_high,x
    adc #0
    sta $73
    clc

    lda player_ys
    cmp #1
    bne plot_char_bank2_y0
    clc
    lda $72
    adc #4
    sta $72
    jmp plot8x24_y1

    plot_char_bank2_y0:
    jmp plot8x24_y0

plot_player:

    lda bank_number
    cmp #0
    bne plot_player_plot_bank2

        clc
        jmp plot_char_bank1

    plot_player_plot_bank2:

        clc
        jmp plot_char_bank2

check_tile:         ; $80=x position (0-39)
                    ; $81=y position (0-23) (measured from the top of the
                    ;           playing area, not the top row of the scenery)
                    ; returns C set if tile found or C clear if not

    lda $81         ; For y positions less than 8 do not check the
    cmp #8          ; corresponding row.
    bcs check_tile_row

    rts

    check_tile_row:
    sbc #8
    clc

    tax
    jsr read_row_address

    lda initial_row_offsets,x
    cmp $80
    beq check_tile_spans
    bcc check_tile_spans

    clc
    lda initial_row_tiles,x
    jmp check_tile_visible  ; Check whether the tile is visible and return.

    check_tile_spans:
    clc

    sta $74                 ; Store the row offset of the next span.

    check_tile_spans_loop:

        ldy #1
        lda ($76),y         ; Load the number of tiles minus 1, n - 1.
        adc #1              ; n
        bcs check_tile_spans_loop_found
        adc $74             ; Add to the row offset
        bcs check_tile_spans_loop_found

        cmp $80
        beq check_tile_spans_loop_next
        bcc check_tile_spans_loop_next

        check_tile_spans_loop_found:

        clc
        ldy #0
        lda ($76),y             ; Load the type number, t,
        jmp check_tile_visible  ; Check whether the tile is visible and return,
                                ; the type number in A, leaving $76,$77
                                ; pointing to the span that was found.

        check_tile_spans_loop_next:

        cmp #40
        bpl check_tile_spans_endloop

        sta $74             ; and store the result.

        lda $76             ; Increment the row address.
        adc #2
        sta $76
        lda $77
        adc #0
        sta $77
        clc

        jmp check_tile_spans_loop

    check_tile_spans_endloop:

    clc             ; In theory, we should never reach here.
    rts

; Special tiles have numbers greater or equal to 16 (0x10). The top four bits
; are used to represent properties of each tile: vcdt nnnn.
; v = visible (initial visibility of the tile)
; c = collectable item
; d = door that can be opened with a corresponding key - two consecutive tile
;     numbers are used for the door and key tiles
; t = treasure - a pair of adjacent tiles is used to represent this in the
;     level, though the tile numbers used are not consecutive

check_tile_visible:             ; A=tile number
                                ; returns C set if tile is visible or C
                                ; clear if not
    cmp #$10
    bcs check_tile_visible_special

    cmp #1                      ; Return C set for tiles 1-15; C clear for 0
    rts

    check_tile_visible_special:
    tay                         ; transfer the tile number to Y
    lda ($82),y                 ; load the visibility of the tile
    cmp #$80
    bcs check_tile_visible_next

    clc                         ; not visible, so clear C to indicate this
    rts

    check_tile_visible_next:    ; the tile is visible

    and #$7f                    ; mask off the visible bit
    cmp #$40                    ; check for collectable objects (vCdtnnnn)
    bcs check_tile_collect_visible_object

    ; Non-collectable (scenery) objects

    and #$3f                    ; mask off visible and collectable bits
    cmp #$20                    ; check for doors that can be opened with a key
                                ; (vcDtnnnn)
    bcc check_tile_visible_exit ; any other visible scenery objects cannot be
                                ; walked through (000tnnnn)

    ; For doors, check the visibility of the corresponding key special tile.
    clc
    sty $8c                     ; temporarily store the special tile number
    tya                         ; a special scenery tile (00Dtnnnn)
    eor #$01                    ; check the corresponding collectable tile
    tay                         ; (00DtnnnN)
    lda ($82),y
    cmp #0
    bne check_tile_visible_exit ; if visible (i.e. not collected) then exit

    ldy $8c                     ; restore the special tile number (00Dtnnnn)
    jmp make_tile_invisible     ; make all tiles of that type invisible and exit

check_tile_collect_visible_object:

    and #$1f                ; mask off the visible, collectable and door bits
    cmp #$10                        ; check for treasure (vcdTnnnn)
    bcs check_tile_collect_treasure ; remove both parts of the object 

    jsr plot_collected_object       ; not treasure, just a regular object
    jmp make_tile_invisible ; make all tiles of this type invisible and exit

check_tile_collect_treasure:

    clc

    jsr plot_collected_object       ; show the item of treasure in the header
    jsr make_tile_invisible         ; make all tiles of this type invisible

    tya
    eor #1                          ; do the same for the corresponding tile
    tay

    jsr plot_collected_object       ; show the item of treasure in the header
    jsr make_tile_invisible         ; make all tiles of this type invisible

    check_tile_visible_exit:
    sec
    rts

plot_collected_object:  ; Y=special tile number

    lda ($84),y                     ; load the tile number
    jsr read_sprite_address_next    ; $70,$71=sprite address

    sty $8c         ; temporarily store the special tile number
    tya             ; tile 
    and #$0f        ; convert the tile number into a screen position
    asl
    asl
    asl
    sta $8d                         ; temporarily store the screen offset
    adc #top_panel_objects_bank1_low
    sta $72
    lda #top_panel_objects_bank1_high
    adc #0
    sta $73
    clc

    jsr plot_tile_bank

    ldy $8c                         ; retrieve the special tile number
    lda ($84),y                     ; load the tile number
    jsr read_sprite_address_next    ; $70,$71=sprite address

    lda $8d                         ; retrieve the screen offset
    adc #top_panel_objects_bank2_low
    sta $72
    lda #top_panel_objects_bank2_high
    adc #0
    sta $73
    clc

    jsr plot_tile_bank
    ldy $8c                         ; restore the special tile number
    rts

make_tile_invisible:    ; Y=special tile number

    lda #0
    sta ($82),y         ; make the tile invisible
    clc
    rts

check_move_right:

    lda bank_number
    cmp #1
    bne check_move_right_continue

    clc             ; If bank 2 is showing, we can move right without checking.
    rts

    check_move_right_continue:
    clc

    lda player_x
    adc #2
    sta $80
    lda player_y
    sta $81
    clc

    jmp check_move  ; branch then exit

player_move_right:

    clc
    jsr check_move_right
    bcs player_move_right_cannot_move

    jmp scroll_right_update     ; branch then exit

    player_move_right_cannot_move:

    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

check_move_left:

    lda bank_number
    cmp #1
    bne check_move_left_continue

    clc             ; If bank 2 is showing, we can move left without checking.
    rts

    check_move_left_continue:
    clc

    lda player_x
    sec
    sbc #1
    sta $80
    clc
    lda player_y
    sta $81

    ; fall through into the next routine

check_move:

    lda #2          ; Start with an offset of 2 from the player's row number.
    sta $7c

    lda #0          ; Use a byte to record occupied tiles. Since we start at
    sta $7d         ; the player's top row, the order of bits is 0000tmb[f] for
                    ; top, middle, bottom and an optional falling bit.
    lda player_falling
    cmp #0
    beq check_move_loop

    inc $7c         ; If the player is falling then we need to check an
                    ; additional tile, below and to the left/right.

    check_move_loop:

        asl $7d
        clc
        jsr check_tile
        bcc check_move_next
        clc

        lda $7d     ; Set a bit to indicate that this tile is occupied.
        ora #1
        sta $7d

        check_move_next:

        inc $81
        dec $7c
        bpl check_move_loop

    lda $7d                 ; If all tiles are empty then allow the move.
    cmp #0
    beq check_move_exit_ok

    lda player_falling      ; If some tiles are not empty while falling then
    cmp #0                  ; stop moving.
    bne check_move_exit_not_ok

    lda player_jumping      ; If some tiles are not empty while jumping then
    cmp #0                  ; stop moving.
    bne check_move_exit_not_ok

    lda $7d                 ; If more than the lowest tile is blocked then
    cmp #$01                ; stop moving.
    bne check_move_exit_not_ok

    jsr plot_player         ; Move the player up by one tile.
    dec player_y            ; We should really check to make sure that there
    jsr plot_player         ; is space above the player to do this.

    clc
    rts

    check_move_exit_not_ok:
    sec
    rts

    check_move_exit_ok:
    clc
    rts

player_move_left:

    clc
    jsr check_move_left
    bcs player_move_left_cannot_move

    jmp scroll_left_update     ; branch then exit

    player_move_left_cannot_move:

    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

jump_steps_y:    .byte 0,1,1,1,1,0,0,0
jump_offsets_ys: .byte 0,0,0,0,1,0,0,0

player_jump:

    clc

    ldx player_jumping      ; Load the number of rows to move.
    lda jump_steps_y,x

    cmp #0                  ; If there are no rows to move then stop jumping.
        beq player_jump_check_after

    lda player_y
    sta $81

    dec $81
    clc

    lda player_x
    sta $80
    jsr check_tile
    bcs player_jump_stop_jumping

    inc $80

    jsr check_tile
    bcs player_jump_stop_jumping

    lda bank_number             ; When half way across a cell, check another
    cmp #1                      ; cell above the player since they could be
        bne player_jump_move_up ; under one or more of three tiles.

    inc $80

    jsr check_tile
    bcs player_jump_stop_jumping

    player_jump_move_up:

        lda $81
        sta player_y

    player_jump_check_after:
    clc

    ldx player_jumping              ; Load the number of rows to move.
    lda jump_offsets_ys,x
    sta player_ys

    inx
    cpx #8                          ; After the end of the list of offsets,
    bcs player_jump_stop_jumping    ; stop jumping.

    stx player_jumping
    clc
    rts

    player_jump_stop_jumping:
    clc

    lda #0
    sta player_jumping
    lda #0
    sta player_ys

    clc
    rts

fall_steps_y:    .byte 0,0,1,1
fall_offsets_ys: .byte 0,1,0,0

player_fall:        ; sets C if the player is moving horizontally

    lda player_moving
    cmp #1
    bne player_fall_not_moving_left

    jsr player_move_left
    sec
    rts

    player_fall_not_moving_left:

    cmp #2
    bne player_fall_not_moving_right

    jsr player_move_right
    sec
    rts

    player_fall_not_moving_right:

    ; When not moving horizontally, the player character must be unplotted and
    ; replotted because redrawing due to scrolling does not occur.

    lda #19
    jsr $fff4
    jsr plot_player

    jsr player_drop

    jsr plot_player

    rts

player_drop:

    clc
    ldx player_falling
    lda fall_steps_y,x
    adc player_y
    sta player_y

    lda fall_offsets_ys,x
    sta player_ys

    cpx #3                  ; Do not increment the falling counter beyond the
    beq player_drop_exit    ; last falling offset.

    inx
    stx player_falling

    player_drop_exit:
    clc
    rts

read_screen_address_bank1:  ; X=row, A=column offset
                            ; sets $72,$73

    asl                     ; Multiply o by 8
    asl
    asl
    sta $72
    lda #0
    adc #0
    sta $73
    clc

    lda $72
    adc bank1_rows_low,x    ; Add to the screen start address for the
    sta $72                 ; row, R, to get x.
    lda $73
    adc bank1_rows_high,x
    sta $73                 ; x ($72,$73)
    clc

    rts

read_screen_address_bank2:  ; X=row, A=column offset
                            ; sets $72,$73=screen address

    asl                     ; Multiply o by 8
    asl
    asl
    sta $72
    lda #0
    adc #0
    sta $73
    clc

    lda $72
    adc bank2_rows_low,x    ; Add to the screen start address for the
    sta $72                 ; row, R, to get x.
    lda $73
    adc bank2_rows_high,x
    sta $73                 ; x ($72,$73)
    clc

    rts

read_sprite_address:        ; $76,$77=span address
                            ; sets $70,$71=sprite address

    cmp #$10
    bcc read_sprite_address_next

    jsr read_visible_sprite     ; check whether the sprite is visible
                                ; (it represents a special tile)

    read_sprite_address_next:   ; a regular tile
    clc

    and #$1f                    ; mask off the top 3 bits,
    asl
    asl
    asl
    adc #sprite_area_low        ; add to S to get S1.
    sta $70
    lda #sprite_area_high
    adc #0
    sta $71                     ; S1 ($70,$71)

    clc
    rts

read_left_sprite_address:       ; A=tile number in high 4 bits
                                ; sets $70,$71=sprite address

    cmp #$10
    bcc read_left_sprite_address_next

    jsr read_visible_sprite     ; check whether the sprite is visible
                                ; (it represents a special tile)

    read_left_sprite_address_next:  ; a regular tile
    clc

    and #$1f                    ; mask off the top 3 bits,
    asl
    asl
    asl
    adc #left_sprites_low       ; add to S to get S2.
    sta $70
    lda #left_sprites_high
    adc #0
    sta $71                     ; S2 ($70,$71)
    clc

    rts

read_rotated_sprite_address:    ; A=tile number
                                ; sets $70,$71=sprite address

    cmp #$10
    bcc read_rotated_sprite_address_next

    jsr read_visible_sprite     ; check whether the sprite is visible
                                ; (it represents a special tile)

    read_rotated_sprite_address_next:   ; a regular tile
    clc

    and #$1f                    ; mask off the top 3 bits,
    asl
    asl
    asl
    adc #rotated_sprites_low    ; add to S to get S1.
    sta $70
    lda #rotated_sprites_high
    adc #0
    sta $71                 ; S1 ($70,$71)
    clc

    rts

read_right_sprite_address:      ; A=tile number in high 4 bits
                                ; sets $80,$81=sprite address

    cmp #$10
    bcc read_right_sprite_address_next

    jsr read_visible_sprite     ; check whether the sprite is visible
                                ; (it represents a special tile)

    read_right_sprite_address_next: ; a regular tile
    clc

    and #$1f                    ; mask off the top 3 bits,
    asl
    asl
    asl
    adc #right_sprites_low      ; add to S to get S2.
    sta $80
    lda #right_sprites_high
    adc #0
    sta $81                     ; S2 ($80,$81)
    clc

    rts

read_visible_sprite:    ; read the regular tile number for a special tile

    tay
    lda ($82),y                 ; load the visibility of the tile
    cmp #$80
    bcs read_visible_sprite_visible

    read_visible_sprite_exit:
    lda #0
    rts

    read_visible_sprite_visible:
    lda ($84),y                 ; load the tile number from a table
    rts

track_position: ; Scroll back to the last stored position.

    clc

    lda scroll_offset_high
    cmp tracking_high
    beq track_position_check_low
    bcs track_position_scroll_left
    bcc track_position_scroll_right

    track_position_check_low:
    lda scroll_offset_low
    cmp tracking_low
    beq track_position_check_bank
    bcs track_position_scroll_left
    bcc track_position_scroll_right

    track_position_check_bank:
    lda bank_number
    cmp #0
    beq track_position_exit
    bcs track_position_scroll_left

    track_position_scroll_right:
    jsr scroll_right_update
    sec
    rts

    track_position_scroll_left:
    jsr scroll_left_update
    sec
    rts

    track_position_exit:
    clc
    rts

; Monster plotting routines (nnxa)

monster_sprite_low: .byte monster_spr_low0,     monster_spr_low1
                    .byte monster_spr_sh_low0,  monster_spr_sh_low1
                    .byte monster_spr_low2,     monster_spr_low3
                    .byte monster_spr_sh_low2,  monster_spr_sh_low3
monster_sprite_high:.byte monster_spr_high0,    monster_spr_high1
                    .byte monster_spr_sh_high0, monster_spr_sh_high1
                    .byte monster_spr_high2,    monster_spr_high3
                    .byte monster_spr_sh_high2, monster_spr_sh_high3

plot_monster_bank1:       ; X=monster y offset,Y=offset of monster y offset

    lda bank1_char_rows_low,x   ; y position (low)
    adc $72
    sta $72
    lda $73
    adc bank1_char_rows_high,x  ; y position (high)
    sta $73
    clc

    lda $72                 ; Subtract the starting offset into the data
    sec                     ; from the screen position to cope with the case
    sbc $8c                 ; where the monster is partially off the left hand
    sta $72                 ; side of the screen.
    lda $73
    sbc #0
    sta $73
    clc

    iny
    lda ($86),y                 ; dy offset
    cmp #0
    bne plot8x8_x0_y1
    jmp plot8x8_x0_y0

plot_monster_bank2:       ; X=monster y offset,Y=offset of monster y offset

    lda bank2_char_rows_low,x   ; y position (low)
    adc $72
    sta $72
    lda $73
    adc bank2_char_rows_high,x  ; y position (high)
    sta $73
    clc

    lda $72                 ; Subtract the starting offset into the data
    sec                     ; from the screen position to cope with the case
    sbc $8c                 ; where the monster is partially off the left hand
    sta $72                 ; side of the screen.
    lda $73
    sbc #0
    sta $73
    clc

    iny
    lda ($86),y                 ; dy offset
    cmp #0
    bne plot8x8_x0_y1

plot8x8_x0_y0:          ; $70,$71=source address
                        ; $72,$73=destination address
                        ; $8c=first offset in sprite data
                        ; $8d=last offset in sprite data
    ldy $8d

    plot8x8_x0_y0_loop:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        cpy $8c
        beq plot8x8_x0_y0_exit
        dey
        jmp plot8x8_x0_y0_loop

    plot8x8_x0_y0_exit:
    clc
    rts

plot8x8_x0_y1:          ; $70,$71=source address
                        ; $72,$73=destination address
                        ; $8c=first offset in sprite data
                        ; $8d=last offset in sprite data
    ldy $8d

    plot8x8_x0_y1_loop:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        cpy $8c
        beq plot8x8_x0_y1_exit
        dey
        jmp plot8x8_x0_y1_loop

    plot8x8_x0_y1_exit:
    clc
    rts

plot8x8_lengths: .byte 15, 23

plot_monsters:

    lda bank_number
    cmp #0
    bne plot_monsters_bank2
    jmp plot_monsters_bank1

plot_monsters_bank1:            ; Entry point for plotting monsters on bank 1.

    jsr set_monsters_bank1
    jmp plot_monsters_pre_loop

plot_monsters_bank2:            ; Entry point for plotting monsters on bank 2.

    jsr set_monsters_bank2
    jmp plot_monsters_pre_loop

set_monsters_bank1:             ; General routine for setting the monster
                                ; plotting routine. Could be moved into
    lda #<plot_monster_bank1    ; plot_monsters_bank1 later.
    sta $7a
    lda #>plot_monster_bank1
    sta $7b
    rts

set_monsters_bank2:             ; General routine for setting the monster
                                ; plotting routine. Could be moved into
    lda #<plot_monster_bank2    ; plot_monsters_bank2 later.
    sta $7a
    lda #>plot_monster_bank2
    sta $7b
    rts

plot_monsters_pre_loop:

    lda #0

    plot_monsters_loop:

        sta $88                     ; store the offset temporarily

        tay
        lda ($86),y                 ; type, animation and dx
        cmp #0
        beq plot_monsters_loop_next

        jsr plot_monster

        plot_monsters_loop_next:
        clc

        lda $88
        adc #4
        cmp #$10
        bne plot_monsters_loop

    plot_monsters_exit:
    clc
    rts

plot_monster:   ; $7a,$7b=sprite plotting routing for a given bank
                ; (set up in set_monsters_bank1 or set_monsters_bank2)
                ; A=monster type
                ; Y=offset into monster table (0, 4, 8, 12)

    ; Determine the sprite to use from the type and dx value, converting the
    ; value to an offset into the sprite address arrays.
    and #monster_plot_bits      ; Mask off the non-sprite-related bits.
    tax
    and #monster_dx_bit
    lsr
    sta $8c                     ; dx=0 or 1

    lda monster_sprite_low,x    ; load the sprite address
    sta $70
    lda monster_sprite_high,x
    sta $71

    ldx $8c                 ; Use the dx value to look up the length of data
    lda plot8x8_lengths,x   ; to plot for the sprite.
    sta $8d
    lda #0                  ; Plot from the beginning of the sprite data.
    sta $8c

    iny
    lda ($86),y                 ; x offset
    sta $8b                     ; Store the x offset.

    cmp #254                    ; Check for x >= 254 (-2 >= x > 0).
    bcc plot_monster_not_left

    cmp #255
    beq plot_monster_x_minus_one

        lda #0                  ; Only plot from the left hand edge.
        sta $8b

        lda #16
        sta $8c
        cmp $8d                 ; If the start offset is greater than the
        bcc plot_monster_plot   ; finish offset then exit.

            clc
            rts

    plot_monster_x_minus_one:

        lda #0                  ; Only plot from the left hand edge.
        sta $8b

        lda #8
        sta $8c
        jmp plot_monster_plot

    plot_monster_not_left:

    cmp #38
    bcc plot_monster_plot       ; If x < 38 then just plot everything.
    beq plot_monster_x_plus_one

    cmp #40
    bcc plot_monster_x_plus_two

        clc                     ; x >= 40
        rts

    plot_monster_x_plus_one:    ; x = 38

        lda #15
        sta $8d
        jmp plot_monster_plot

    plot_monster_x_plus_two:    ; x = 39

        lda #7
        sta $8d

    plot_monster_plot:

    lda $8b                     ; Retrieve the x offset.
    asl
    asl
    asl                         ; x position
    sta $72
    lda #0
    adc #0
    sta $73
    clc

    iny
    lda ($86),y                 ; y offset
    tax

    jmp ($7a)
    ; The plotting routine returns to the caller of this routine.

; Monster creation/destruction and movement.

create_monster_left:

    lda monster_left_index
    ldx visible_monster_left_index  ; X=visible index
    jsr create_monster
    bcs create_monster_left_exit

    lda #254
    dex
    dex
    sta monster_positions_address,x ; Store the x coordinate.

    create_monster_left_exit:
    clc
    rts

create_monster_right:

    lda monster_right_index
    ldx visible_monster_right_index ; X=visible index
    jsr create_monster
    bcs create_monster_right_exit

    lda #40
    dex
    dex
    sta monster_positions_address,x ; Store the x coordinate.

    create_monster_right_exit:
    clc
    rts

create_monster:                     ; A=index
                                    ; X=visible index
    jsr read_monster_row_address
    ldy #0
    lda ($76),y                     ; Read the monster type.
    cmp #0                          ; If no monster is defined then exit;
    bne create_monster_check_slot   ; otherwise create the monster.
    sec
    rts

    create_monster_check_slot:

    tay                             ; Temporarily store the type.

    lda monster_positions_address,x
    cmp #0
    beq create_monster_create
    rts

    create_monster_create:

    lda bank_number
    eor #$01
    asl                 ; 00xa (dx = !bank; a = 0)
    sta $8c

    tya                             ; Recover the type.
    and #monster_data_type_bits     ; Extract the monster type number (00000nn0).
    asl                             ; 0000nn00
    ora $8c                         ; 0000nnxa (from above)
    ora #monster_existence_bit      ; Set the existence bit.
    sta $8c

    tya
    and #monster_data_axis_bit
    ror
    ror
    ror
    ora $8c
    sta monster_positions_address,x

    tya                             ; Recover the original type value.
    and #$f8
    lsr
    lsr
    lsr

    inx
    inx
    sta monster_positions_address,x ; Store the y coordinate.
    inx
    lda #0
    sta monster_positions_address,x ; Store the dy coordinate.

    clc
    rts

move_monsters:

    ; Check the monster movement counter and perform updates now if necessary.
    lda monster_movement_counter
    and #$07
    beq move_monsters_pre_loop

    clc
    rts

move_monsters_pre_loop:

    lda #0
    sta $88

    move_monsters_loop:

        ldy $88
        lda ($86),y                 ; Load the type, animation flag and dx.
        cmp #0
        beq move_monsters_loop_next

        eor #monster_animation_bit  ; Flip the animation bit.
        tax                         ; Temporarily store the type/dx byte.

        and #monster_axis_bit
        cmp #monster_vertical_motion
        bne move_monsters_loop_update_type

            jsr move_monster_vertically

        move_monsters_loop_update_type:

        ldy $88
        txa
        sta ($86),y                 ; Store the changed type.

        move_monsters_loop_next:
        clc

        lda $88
        adc #4
        cmp #$10
        beq move_monsters_exit

        sta $88                     ; Store the offset temporarily.
        jmp move_monsters_loop

    move_monsters_exit:
    clc
    rts

move_monster_vertically:    ; $86,$87=monster table
                            ; $88=offset into monster table
                            ; X=monster type
                            ; Y=offset into monster table (initially 0)
        iny
        iny                         ; Select the y offset.

        txa                         ; Recover the type.
        and #monster_direction_bit
        cmp #$00
        bne move_monsters_down

        ; Upward motion

        iny                         ; Select the dy value.
        lda ($86),y

        eor #$01                    ; dy = !dy
        sta ($86),y

        dey                         ; Select the y offset.
        lda ($86),y
        cmp #0
        beq move_monsters_change_direction

            lda ($86),y
            sec
            sbc #1                  ; y -= 1
            clc
            sta ($86),y
            rts

        move_monsters_change_direction:

        txa                         ; Recover the type.
        eor #monster_direction_bit
        tax
        rts

        move_monsters_down:

        ; Downward motion

        lda ($86),y
        cmp #23
        beq move_monsters_change_direction

            iny                         ; Select the dy value.
            lda ($86),y

            eor #$01                    ; dy = !dy
            sta ($86),y

            dey                         ; Select the y offset.
            lda ($86),y
            adc #1
            sta ($86),y

    clc
    rts

scroll_monsters_left:

    lda #0

    scroll_monsters_left_loop:

        sta $88                     ; store the offset temporarily

        tay
        lda ($86),y                 ; type, animation flag and dx
        cmp #0
        beq scroll_monsters_left_loop_next

        ; Move the monster right on screen.

        eor #monster_dx_bit         ; toggle dx
        sta ($86),y

        and #monster_dx_bit
        bne scroll_monsters_left_loop_dx_only

        clc
        iny
        lda ($86),y                 ; x offset
        cmp #40
        bcc scroll_monsters_left_loop_move_monster
        cmp #254
        bcs scroll_monsters_left_loop_move_monster

        lda #0                      ; Clear the type in the monster table.
        ldy $88
        sta ($86),y

        jmp scroll_monsters_left_loop_next

        scroll_monsters_left_loop_move_monster:
        clc
        adc #1
        sta ($86),y                 ; x offset

        scroll_monsters_left_loop_dx_only:

        scroll_monsters_left_loop_next:
        clc

        lda $88
        adc #4
        cmp #$10
        bne scroll_monsters_left_loop

    scroll_monsters_left_exit:
    jmp move_monsters

scroll_monsters_right:

    lda #0

    scroll_monsters_right_loop:

        sta $88                     ; store the offset temporarily

        tay
        lda ($86),y                 ; type, animation flag and dx
        cmp #0
        beq scroll_monsters_right_loop_next

        ; Move the monster left on screen.

        eor #monster_dx_bit         ; toggle dx
        sta ($86),y

        and #monster_dx_bit
        beq scroll_monsters_right_loop_dx_only

        iny
        lda ($86),y                 ; x offset
        cmp #254
        bne scroll_monsters_right_loop_move_monster

        lda #0
        ldy $88                     ; Clear the type in the monster table.
        sta ($86),y

        jmp scroll_monsters_right_loop_next

        scroll_monsters_right_loop_move_monster:
        sec
        sbc #1
        sta ($86),y                 ; x offset

        scroll_monsters_right_loop_dx_only:

        scroll_monsters_right_loop_next:
        clc

        lda $88
        adc #4
        cmp #$10
        bne scroll_monsters_right_loop

    scroll_monsters_right_exit:
    jmp move_monsters

switch_characters:

    ; Switch the left sprites then generate right sprites from them.
    ldx #95
    switch_characters_left_loop:

        ldy player_left1,x
        lda player_left_alt1,x
        sta player_left1,x
        tya
        sta player_left_alt1,x

        ldy player_right1,x
        lda player_right_alt1,x
        sta player_right1,x
        tya
        sta player_right_alt1,x

        dex
        bpl switch_characters_left_loop

    clc
    rts

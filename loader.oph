; Copyright (C) 2011 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $3500

.include "constants.oph"

main:
    lda #22         ; MODE 5
    jsr $ffee
    lda #5
    jsr $ffee

    lda #23         ; disable flashing cursor
    jsr $ffee
    lda #1
    jsr $ffee
    ldx #7
    cursor_loop:
        lda #0
        jsr $ffee
        dex
        bpl cursor_loop

    jsr set_core_palette

    ldx #0
    title_text_loop:
        lda title_text,x
        jsr $ffee
        inx
        cpx #[title_text_end - title_text]
        bne title_text_loop

    jsr cassette_init

    ldx #0
    init_load_window_loop:

        lda init_load_window_vdu_bytes,x
        jsr $ffee
        inx
        cpx #5
        bne init_load_window_loop

    lda #255
    ldx #<tiles_block
    ldy #>tiles_block
    jsr $ffdd

    lda #255
    ldx #<sprites_block
    ldy #>sprites_block
    jsr $ffdd

    lda #255
    ldx #<levels_block
    ldy #>levels_block
    jsr $ffdd

    lda #255
    ldx #<top_panel_block
    ldy #>top_panel_block
    jsr $ffdd

    lda #255
    ldx #<code_block
    ldy #>code_block
    jsr $ffdd

    jsr cassette_quit

    lda #140
    jsr $fff4   ; *TAPE (reclaim any workspace used on high PAGE systems)

    ; Copy the panel onto bank1.
    jsr copy_panel

    jmp code_start_address

set_core_palette:

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    rts

set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $3dfb
    lda $71
    sta $3dfc
    lda #0
    sta $3dfd
    sta $3dfe
    sta $3dff

    lda #$c         
    ldx #$fb
    ldy #$3d
    jsr $fff1
    rts

copy_panel:

    lda #$00
    sta $70
    lda #$30
    sta $71
    lda #$00
    sta $72
    lda #$58
    sta $73

    ldy #0

    copy_top_panel_loop:

        lda ($70),y
        sta ($72),y

        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #1
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        cmp #$5d
        bne copy_top_panel_loop

    clc
    rts

tiles_block: .byte <tiles_file_name, >tiles_file_name
             .byte sprite_area_low, sprite_area_high, 0, 0
             .byte sprite_area_low, sprite_area_high, 0, 0
             .byte sprite_area_length_low, sprite_area_length_high, 0, 0
             .byte sprite_area_end_low, sprite_area_end_high, 0, 0

tiles_file_name: .byte "TILES", 13

sprites_block: .byte <sprites_file_name, >sprites_file_name
             .byte char_area_low, char_area_high, 0, 0
             .byte char_area_low, char_area_high, 0, 0
             .byte char_area_length_low, char_area_length_high, 0, 0
             .byte char_area_end_low, char_area_end_high, 0, 0

sprites_file_name: .byte "SPRITES", 13

levels_block: .byte <levels_file_name, >levels_file_name
             .byte levels_address_low, levels_address_high, 0, 0
             .byte levels_address_low, levels_address_high, 0, 0
             .byte levels_length_low, levels_length_high, 0, 0
             .byte levels_end_low, levels_end_high, 0, 0

levels_file_name: .byte "LEVELS", 13

top_panel_block: .byte <top_panel_file_name, >top_panel_file_name
             .byte top_panel_address_low, top_panel_address_high, 0, 0
             .byte top_panel_address_low, top_panel_address_high, 0, 0
             .byte top_panel_length_low, top_panel_length_high, 0, 0
             .byte top_panel_end_low, top_panel_end_high, 0, 0

top_panel_file_name: .byte "PANEL", 13

code_block: .byte <code_file_name, >code_file_name
             .byte code_start_low, code_start_high, 0, 0
             .byte code_start_low, code_start_high, 0, 0
             .byte code_length_low, code_length_high, 0, 0
             .byte code_end_low, code_end_high, 0, 0

code_file_name: .byte "CODE", 13

init_load_window_vdu_bytes: .byte 28,0,28,19,26

title_text: .byte "   Castle Raider", 13, 10, 13, 10
            .byte " Prerelease version", 13, 10
            .byte " Copyright (C) 2012", 13, 10
            .byte "    David Boddie", 13, 10
            .byte "GNU GPL v3 or later"
title_text_end:

cassette_original_irq1v:
cassette_original_irq1v_low: .byte 0
cassette_original_irq1v_high: .byte 0

cassette_init:

    ldx #0
    lda cassette_markers,x      ; total number of markers
    sta $72

    inx
    ldy #0
    cassette_init_values_loop:

        lda cassette_markers,x      ; load the address of each marker
        sta $70
        inx
        lda cassette_markers,x
        sta $71
        inx
        lda cassette_markers,x      ; store the inverse value in the address
        eor #$ff
        sta ($70),y
        inx

        dec $72
        bpl cassette_init_values_loop

    stx cassette_markers_end

    sei         ; disable interrupts

    lda $204
    sta cassette_original_irq1v_low
    lda $205
    sta cassette_original_irq1v_high

    lda #<cassette_interrupt_routine
    sta $204
    lda #>cassette_interrupt_routine
    sta $205

    cli         ; enable interrupts
    rts

cassette_quit:
    sei         ; disable interrupts

    lda cassette_original_irq1v_low
    sta $204
    lda cassette_original_irq1v_high
    sta $205

    cli         ; enable interrupts
    rts

cassette_marker_index: .byte 1
cassette_markers_end:  .byte 0
cassette_screen_index: .byte 0

cassette_screen_value:  .byte 1
cassette_screen_values: .byte $f0, $c0

cassette_interrupt_routine:
    pha
    txa
    pha
    tya
    pha

    ldx cassette_marker_index       ; load the current index to a marker
    cpx cassette_markers_end        ; compare it to the end index
    beq cassette_interrupt_routine_continue

    lda cassette_markers,x          ; load the address to check
    sta $70
    inx
    lda cassette_markers,x
    sta $71

    ldy #0
    lda ($70),y                     ; load the marker value
    inx
    cmp cassette_markers,x          ; compare it with the value in the table
    bne cassette_interrupt_routine_continue
    clc

    inx
    stx cassette_marker_index       ; store the new index

    ldx cassette_screen_value
    lda cassette_screen_values,x
    ldy #3
    ldx cassette_screen_index   ; load the position on the screen to plot to
    cassette_interrupt_routine_plot_loop:

        sta $7610,x
        inx
        dey
        bpl cassette_interrupt_routine_plot_loop

    dec cassette_screen_value
    bpl cassette_interrupt_routine_continue
    clc

    lda #1
    sta cassette_screen_value
    lda cassette_screen_index
    adc #8
    sta cassette_screen_index

    cassette_interrupt_routine_continue:
    clc

    pla
    tay
    pla
    tax
    pla
    jmp (cassette_original_irq1v)

cassette_markers:

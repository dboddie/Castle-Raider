; Copyright (C) 2013 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $0e00

.include "constants.oph"

.alias scrolled                         $7f
.alias scroll_offset_low                $8e
.alias scroll_offset_high               $8f

; Declare these here to make it easy to see that they are being used.
.alias tile_visibility_table_low        $82
.alias tile_visibility_table_high       $83
.alias special_tile_numbers_table_low   $84
.alias special_tile_numbers_table_high  $85
.alias monster_positions_table_low      $86
.alias monster_positions_table_high     $87

; Each monster type is defined as yyyyynnd.
.alias monster_data_axis_bit            $01
.alias monster_data_type_bits           $06

; Each monster visible type is defined as nnxa.
.alias monster_animation_bit            $01
.alias monster_dx_bit                   $02
.alias monster_type_bits                $0c
.alias monster_plot_bits                $0f
.alias monster_direction_bit            $20
.alias monster_axis_bit                 $40
.alias monster_existence_bit            $80

.alias monster_horizontal_motion        $00
.alias monster_vertical_motion          $40

jmp init

.include "plotting.oph"
.include "scrolling.oph"
.include "bank_routines.oph"
.include "monsters.oph"

init:
    ; Set character's initial position and status.

    lda #19
    sta player_x
    lda #19
    sta player_y
    sta tracking_y      ; Set the vertical tracking position of the character.
    lda #0
    sta player_ys
    lda #2
    sta player_animation
    lda #0
    sta player_jumping
    sta player_moving
    sta player_falling
    lda #9
    sta player_lives
    lda #0
    sta player_lost

    ; Initialise the tile visibility values.

    ldx #31

    init_tile_visibility_loop:
        lda initial_tile_visibility_address,x
        sta tile_visibility_address,x
        dex
        bpl init_tile_visibility_loop
    clc

    lda #0              ; Use 0 and 1 for banks 1 and 2.
    sta bank_number

    ; Store table addresses in zero page locations for convenient access.
    lda #tile_visibility_low
    sta $82
    lda #tile_visibility_high
    sta $83

    lda #special_tile_numbers_low
    sta $84
    lda #special_tile_numbers_high
    sta $85

    lda #monster_positions_low
    sta $86
    lda #monster_positions_high
    sta $87

    ; Determine the left and right monster indices and offsets.

    lda #0
    sta monster_movement_counter

    ; Initialise the monster positions.

    ldx #15
    lda #0

    init_monster_positions_loop:
        sta monster_positions_address,x
        dex
        bpl init_monster_positions_loop

main:

    jsr clear_bank1
    jsr clear_bank2

    jsr init_scrolling

    jsr show_bank2          ; Hide the bank being plotted.
    jsr initial_plot_bank1
    jsr plot_char_bank1
    jsr plot_monsters_bank1 ; Show any initial monsters.
    jsr show_bank1          ; Show the completed bank.
    jsr initial_plot_bank2

    lda #0                  ; Set the initial scroll offset and tracking offset.
    sta scroll_offset_low
    sta tracking_low
    lda #0
    sta scroll_offset_high
    sta tracking_high

    main_loop:

        lda #0
        sta scrolled

        main_loop_check_lost:

        lda player_lost
        cmp #0
        beq main_loop_check_jump

            lda player_lives
            cmp #0
            beq main_loop_endloop

            jsr track_position      ; Move the player back to the tracking position.
            bcs main_loop_next

            lda #0
            sta player_lost

            lda tracking_y
            sta player_y

            jsr plot_char           ; Plot the character again.

        main_loop_check_jump:

        lda player_jumping
        cmp #0
        bne main_loop_check_fall

            jsr check_beneath

        main_loop_check_fall:

        lda player_falling
        cmp #0
        beq main_loop_allow_movement

            jsr player_fall
            bcs main_loop_next

        main_loop_allow_movement:

            clc

            jsr player_move
            jmp main_loop_next

        main_loop_next:

        lda scrolled
        cmp #0
        bne main_loop_after_monsters

        lda #19
        jsr $fff4
        jsr plot_monsters        ; unplot monsters
        jsr move_monsters
        jsr plot_monsters        ; plot monsters

        main_loop_after_monsters:
        clc

        inc monster_movement_counter
        clc

        ; --- Switch character test code (begin) ---
        ldx #157            ; (SPACE)
        jsr check_key
        cpy #255
        bne not_space

        clc
        jsr plot_char
        jsr switch_characters
        jsr plot_char

        not_space:
        ; --- Switch character test code (end) ---

        ldx #143            ; (Escape)
        jsr check_key
        cpy #255
        bne main_loop

    main_loop_endloop:

    clc
    rts

player_move:

    lda player_jumping
    cmp #0
    beq player_move_check_fall
    clc

    ; Whether moving or not, the player needs to be replotted before any
    ; scrolling occurs because the scrolling routine will replot the player.
    ; This needs to be optimised.

    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot

    jsr player_jump

    jsr plot_player                 ; plot

    lda player_moving
    cmp #1
    bne player_move_not_moving_left

    jsr player_move_left
    clc
    rts

    player_move_not_moving_left:
    cmp #2
    bne player_move_not_moving_right

    jsr player_move_right

    player_move_not_moving_right:

    clc
    rts

    player_move_check_fall:

    lda player_falling
    cmp #0
    beq player_move_check_keys

    clc
    rts

    player_move_check_keys:

    lda #0
    sta player_moving

    ldx #158        ; (Z)
    jsr check_key
    cpy #255
    bne player_move_not_left
    clc

    jsr player_move_left   ; allow the player to jump while moving

    lda #1                  ; 1=moving left
    sta player_moving

    jmp player_move_check_jump

    player_move_not_left:
    clc

    ldx #189        ; (X)
    jsr check_key
    cpy #255
    bne player_move_not_right
    clc

    jsr player_move_right   ; allow the player to jump while moving

    lda #2                  ; 2=moving right
    sta player_moving

    ; jmp player_move_check_jump (fall through)

    player_move_not_right:

    player_move_check_jump:

    lda player_jumping
    cmp #0
    bne player_move_not_jump

    ldx #182        ; (Return)
    jsr check_key
    cpy #255
    bne player_move_not_jump
    clc

    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot

    lda scroll_offset_low
    sta tracking_low
    lda scroll_offset_high
    sta tracking_high
    lda player_y
    sta tracking_y

    jsr player_jump

    jsr plot_player                 ; plot

    player_move_not_jump:

    clc
    rts

check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jmp $fff4   ; Return directly from the OS routine.

check_beneath:

    lda player_y
    cmp #21
    bcs check_beneath_demise_exit

    adc #3
    sta $81
    lda player_x
    sta $80

    jsr check_tile
    bcs check_beneath_exit

    inc $80
    jsr check_tile
    bcs check_beneath_exit

    lda bank_number         ; When half way across a cell, check another cell
    cmp #1                  ; beneath the player since they could be standing
    bne check_beneath_fall  ; on one or more of three tiles.

    clc
    inc $80
    jsr check_tile
    bcs check_beneath_exit

    check_beneath_fall:

    lda player_falling
    cmp #0
        bne check_beneath_fall_exit

    lda #1
    sta player_falling

    check_beneath_fall_exit:
    clc
    rts

    check_beneath_demise_exit:

    jsr player_demise

    check_beneath_exit:
    clc

    lda #0
    sta player_falling
    rts

read_row_address:           ; X=row number
                            ; Returns $76,$77 (row address)

    lda row_table_low,x     ; Load entry a from the table.
    sta $76
    lda row_table_high,x
    sta $77

    lda row_indices,x   ; Load index i from the indices;
    asl                 ; and multiply it by 2 to get i*2.
    adc $76             ; Add i*2 to A to get the address, I, of the
    sta $76             ; starting offset and type.
    lda $77
    adc #0
    sta $77
    clc

    rts

player_sprites_low:  .byte <player_left1, <player_left2, <player_right1, <player_right2
player_sprites_high: .byte >player_left1, >player_left2, >player_right1, >player_right2
player_y_offset:     .byte 0, 4

check_tile:         ; $80=x position (0-39)
                    ; $81=y position (0-23) (measured from the top of the
                    ;           playing area, not the top row of the scenery)
                    ; returns C set if tile found or C clear if not

    lda $81         ; For y positions less than 8 do not check the corresponding
    cmp #8          ; row since there are no level spans in these rows.
    bcs check_tile_row

    rts

    check_tile_row:
    sbc #8
    clc

    tax
    jsr read_row_address

    lda initial_row_offsets,x
    cmp $80
    beq check_tile_spans
    bcc check_tile_spans

    clc
    lda initial_row_tiles,x
    jmp check_tile_visible  ; Check whether the tile is visible and return.

    check_tile_spans:
    clc

    sta $74                 ; Store the row offset of the next span.

    check_tile_spans_loop:

        ldy #1
        lda ($76),y         ; Load the number of tiles minus 1, n - 1.
        adc #1              ; n
        bcs check_tile_spans_loop_found
        adc $74             ; Add to the row offset
        bcs check_tile_spans_loop_found

        cmp $80
        beq check_tile_spans_loop_next
        bcc check_tile_spans_loop_next

        check_tile_spans_loop_found:

        clc
        ldy #0
        lda ($76),y             ; Load the type number, t,
        jmp check_tile_visible  ; Check whether the tile is visible and return,
                                ; the type number in A, leaving $76,$77
                                ; pointing to the span that was found.

        check_tile_spans_loop_next:

        cmp #40
        bpl check_tile_spans_endloop

        sta $74             ; and store the result.

        lda $76             ; Increment the row address.
        adc #2
        sta $76
        lda $77
        adc #0
        sta $77
        clc

        jmp check_tile_spans_loop

    check_tile_spans_endloop:

    clc             ; In theory, we should never reach here.
    rts

; Special tiles have numbers greater or equal to 16 (0x10). The top four bits
; are used to represent properties of each tile: vcdt nnnn.
; v = visible (initial visibility of the tile)
; c = collectable item
; d = door that can be opened with a corresponding key - two consecutive tile
;     numbers are used for the door and key tiles
; t = treasure - a pair of adjacent tiles is used to represent this in the
;     level, and the tile numbers used differ only by the lowest bit

check_tile_visible:             ; A=tile number
                                ; returns C set if tile is visible or C
                                ; clear if not
    cmp #$10
    bcs check_tile_visible_special

    cmp #1                      ; Return C set for tiles 1-15; C clear for 0
    rts

    check_tile_visible_special:
    tay                         ; transfer the tile number to Y
    lda ($82),y                 ; load the visibility of the tile
    cmp #$80
    bcs check_tile_visible_next

    and #$60                    ; Check if both c and d bits are set (indicating
    bne check_tile_portal       ; a portal).

    clc                         ; Not a portal and not visible, so clear C to
    rts                         ; indicate this.

    check_tile_visible_next:    ; the tile is visible

    and #$7f                    ; mask off the visible bit
    cmp #$40                    ; check for collectable objects (vCdtnnnn)
    bcs check_tile_collect_visible_object

    ; Non-collectable (scenery) objects

    and #$3f                    ; mask off visible and collectable bits
    cmp #$20                    ; check for doors that can be opened with a key
                                ; (vcDtnnnn)
    bcc check_tile_visible_exit ; any other visible scenery objects cannot be
                                ; walked through (000tnnnn)

    ; For doors, check the visibility of the corresponding key special tile.
    clc
    sty $8c                     ; temporarily store the special tile number
    tya                         ; a special scenery tile (00Dtnnnn)
    eor #$01                    ; check the corresponding collectable tile
    tay                         ; (00DtnnnN)
    lda ($82),y
    cmp #0
    bne check_tile_visible_exit ; if visible (i.e. not collected) then exit

    ldy $8c                     ; restore the special tile number (00Dtnnnn)
    jmp make_tile_invisible     ; make all tiles of that type invisible and exit

check_tile_collect_visible_object:

    and #$1f                ; mask off the visible, collectable and door bits
    cmp #$10                        ; check for treasure (vcdTnnnn)
    bcs check_tile_collect_treasure ; remove both parts of the object 

    jsr plot_collected_object       ; not treasure, just a regular object
    jmp make_tile_invisible ; make all tiles of this type invisible and exit

check_tile_collect_treasure:

    clc

    jsr plot_collected_object       ; show the item of treasure in the header
    jsr make_tile_invisible         ; make all tiles of this type invisible

    tya
    eor #1                          ; do the same for the corresponding tile
    tay

    jsr plot_collected_object       ; show the item of treasure in the header
    jsr make_tile_invisible         ; make all tiles of this type invisible

    check_tile_visible_exit:
    sec
    rts

check_tile_portal:

    lda ($82),y                     ; load the tile data again
    and #$1f                        ; read the portal number

    clc
    rts

make_tile_invisible:    ; Y=special tile number

    lda #0
    sta ($82),y         ; make the tile invisible
    clc
    rts

check_move_right:

    lda bank_number
    cmp #1
    bne check_move_right_continue

    clc             ; If bank 2 is showing, we can move right without checking.
    rts

    check_move_right_continue:
    clc

    lda player_x
    adc #2
    sta $80
    lda player_y
    sta $81
    clc

    jmp check_move  ; branch then exit

player_move_right:

    clc
    jsr check_move_right
    bcs player_move_right_cannot_move

    jmp scroll_right_update     ; branch then exit

    player_move_right_cannot_move:

    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

check_move_left:

    lda bank_number
    cmp #1
    bne check_move_left_continue

    clc             ; If bank 2 is showing, we can move left without checking.
    rts

    check_move_left_continue:
    clc

    lda player_x
    sec
    sbc #1
    sta $80
    clc
    lda player_y
    sta $81

    ; fall through into the next routine

check_move:

    lda #2          ; Start with an offset of 2 from the player's row number.
    sta $7c

    lda #0          ; Use a byte to record occupied tiles. Since we start at
    sta $7d         ; the player's top row, the order of bits is 0000tmb[f] for
                    ; top, middle, bottom and an optional falling bit.
    lda player_falling
    cmp #0
    beq check_move_loop

    inc $7c         ; If the player is falling then we need to check an
                    ; additional tile, below and to the left/right.

    check_move_loop:

        asl $7d
        clc
        jsr check_tile
        bcc check_move_next
        clc

        lda $7d     ; Set a bit to indicate that this tile is occupied.
        ora #1
        sta $7d

        check_move_next:

        inc $81
        dec $7c
        bpl check_move_loop

    lda $7d                 ; If all tiles are empty then allow the move.
    cmp #0
    beq check_move_exit_ok

    lda player_falling      ; If some tiles are not empty while falling then
    cmp #0                  ; stop moving.
    bne check_move_exit_not_ok

    lda player_jumping      ; If some tiles are not empty while jumping then
    cmp #0                  ; stop moving.
    bne check_move_exit_not_ok

    lda $7d                 ; If more than the lowest tile is blocked then
    cmp #$01                ; stop moving.
    bne check_move_exit_not_ok

    jsr plot_player         ; Move the player up by one tile.
    dec player_y            ; We should really check to make sure that there
    jsr plot_player         ; is space above the player to do this.

    clc
    rts

    check_move_exit_not_ok:
    sec
    rts

    check_move_exit_ok:
    clc
    rts

player_move_left:

    clc
    jsr check_move_left
    bcs player_move_left_cannot_move

    jmp scroll_left_update     ; branch then exit

    player_move_left_cannot_move:

    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

jump_steps_y:    .byte 0,1,1,1,1,0,0,0
jump_offsets_ys: .byte 0,0,0,0,1,0,0,0

player_jump:

    clc

    ldx player_jumping      ; Load the number of rows to move.
    lda jump_steps_y,x

    cmp #0                  ; If there are no rows to move then stop jumping.
        beq player_jump_check_after

    lda player_y
    sta $81

    dec $81
    clc

    lda player_x
    sta $80
    jsr check_tile
    bcs player_jump_stop_jumping

    inc $80

    jsr check_tile
    bcs player_jump_stop_jumping

    lda bank_number             ; When half way across a cell, check another
    cmp #1                      ; cell above the player since they could be
        bne player_jump_move_up ; under one or more of three tiles.

    inc $80

    jsr check_tile
    bcs player_jump_stop_jumping

    player_jump_move_up:

        lda $81
        sta player_y

    player_jump_check_after:
    clc

    ldx player_jumping              ; Load the number of rows to move.
    lda jump_offsets_ys,x
    sta player_ys

    inx
    cpx #8                          ; After the end of the list of offsets,
    bcs player_jump_stop_jumping    ; stop jumping.

    stx player_jumping
    clc
    rts

    player_jump_stop_jumping:
    clc

    lda #0
    sta player_jumping
    lda #0
    sta player_ys

    clc
    rts

fall_steps_y:    .byte 0,0,1,1
fall_offsets_ys: .byte 0,1,0,0

player_fall:        ; sets C if the player is moving horizontally

    lda player_moving
    cmp #1
    bne player_fall_not_moving_left

    jsr player_move_left
    sec
    rts

    player_fall_not_moving_left:

    cmp #2
    bne player_fall_not_moving_right

    jsr player_move_right
    sec
    rts

    player_fall_not_moving_right:

    ; When not moving horizontally, the player character must be unplotted and
    ; replotted because redrawing due to scrolling does not occur.

    lda #19
    jsr $fff4
    jsr plot_player

    jsr player_drop

    jsr plot_player

    rts

player_drop:

    clc
    ldx player_falling
    lda fall_steps_y,x
    adc player_y
    sta player_y

    lda fall_offsets_ys,x
    sta player_ys

    cpx #3                  ; Do not increment the falling counter beyond the
    beq player_drop_exit    ; last falling offset.

    inx
    stx player_falling

    player_drop_exit:
    clc
    rts

player_demise:

    jsr plot_char       ; Unplot the character.

    lda #1
    sta player_lost
    dec player_lives

    rts

track_position: ; Scroll back to the last stored position.

    clc

    lda scroll_offset_high
    cmp tracking_high
    beq track_position_check_low
    bcs track_position_scroll_left
    bcc track_position_scroll_right

    track_position_check_low:
    lda scroll_offset_low
    cmp tracking_low
    beq track_position_check_bank
    bcs track_position_scroll_left
    bcc track_position_scroll_right

    track_position_check_bank:
    lda bank_number
    cmp #0
    beq track_position_exit
    bcs track_position_scroll_left

    track_position_scroll_right:
    jsr scroll_right_update
    sec
    rts

    track_position_scroll_left:
    jsr scroll_left_update
    sec
    rts

    track_position_exit:
    clc
    rts

switch_characters:

    ; Switch the left sprites then generate right sprites from them.
    ldx #95
    switch_characters_left_loop:

        ldy player_left1,x
        lda player_left_alt1,x
        sta player_left1,x
        tya
        sta player_left_alt1,x

        ldy player_right1,x
        lda player_right_alt1,x
        sta player_right1,x
        tya
        sta player_right_alt1,x

        dex
        bpl switch_characters_left_loop

    clc
    rts

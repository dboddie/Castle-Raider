.org $0e00

.include "constants.oph"

.alias max_row_offsets      $1f90 ; the furthest they can be displaced to the right
.alias initial_row_tiles    $1fb0 ; the tile occurring at the left edge of the screen
.alias row_indices          $1fc0 ; indices into each row of the level data
.alias initial_row_offsets  $1fd0 ; current displacements for the rows
.alias row_table_low        $1fe0
.alias row_table_high       $1ff0
.alias level_data_low       $00
.alias level_data_high      $20

.alias player_x             $1fa0
.alias player_y             $1fa1
.alias bank_number          $1fa2
.alias player_animation     $1fa3
.alias player_jumping       $1fa4
.alias player_moving        $1fa5
.alias player_falling       $1fa6

.alias scroll_offset_low    $80
.alias scroll_offset_high   $81

init:

    lda #22         ; MODE 5
    jsr $ffee
    lda #5
    jsr $ffee

    lda #23         ; disable flashing cursor
    jsr $ffee
    lda #1
    jsr $ffee
    ldx #7
    cursor_loop:
        lda #0
        jsr $ffee
        dex
        bpl cursor_loop
    
    jsr set_core_palette
    
    lda #4
    sta player_x
    lda #12
    sta player_y
    lda #2
    sta player_animation
    lda #0
    sta player_jumping
    sta player_moving
    sta player_falling
    
    lda #1              ; Use 1 and 2 for banks 1 and 2.
    sta bank_number

main:

    jsr clear_bank1
    jsr clear_bank2
    
    jsr init_scrolling
    
    jsr show_bank2          ; Hide the bank being plotted.
    jsr initial_plot_bank1
    jsr plot_char_bank1
    jsr show_bank1          ; Show the completed bank.
    jsr initial_plot_bank2
    
    lda #0
    sta scroll_offset_low
    lda #0
    sta scroll_offset_high
    
    main_loop:
    
        lda player_jumping
        cmp #0
        bne main_loop_check_fall
        
            jsr check_beneath
        
        main_loop_check_fall:
        
        lda player_falling
        cmp #0
        beq main_loop_allow_movement
        
            lda player_moving
            cmp #1
            bne main_loop_not_moving_left
            
            jsr player_move_left
            jmp main_loop_next
            
            main_loop_not_moving_left:
            
            cmp #2
            bne main_loop_not_moving_right
            
            jsr player_move_right
            jmp main_loop_next
            
            main_loop_not_moving_right:
            
            lda #19
            jsr $fff4
            jsr plot_player
        
            inc player_y
            jsr plot_player
        
        main_loop_allow_movement:
        
            clc
            
            jsr player_move
            jmp main_loop_next
        
        main_loop_next:
        
        clc
        
        ldx #143            ; (Escape)
        jsr check_key
        cpy #255
        bne main_loop
    
    main_loop_endloop:
    
    clc
    rts

player_move:

    lda player_jumping
    cmp #0
    beq player_move_check_keys
    clc
    
    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot
    
    jsr player_jump
    
    jsr plot_player                 ; plot
    
    lda player_moving
    cmp #2
    bne player_move_not_moving_right
    
    jsr player_move_right
    
    player_move_not_moving_right:
    
    clc
    rts
    
    player_move_check_keys:
    
    lda #0
    sta player_moving
    
    ldx #158        ; (Z)
    jsr check_key
    cpy #255
    bne player_move_not_left
    clc
    
;    player_move_left_wait:
;        ldx #158        ; (Z)
;        jsr check_key
;        cpy #255
;        beq player_move_left_wait
;    clc
    
    lda scroll_offset_low
    cmp #0
    bne player_move_move_left
    lda scroll_offset_high
    cmp #0
    bne player_move_move_left
    
    clc
    rts
    
    player_move_move_left:
    
    jsr player_move_left   ; allow the player to jump while moving
    
    lda #1                  ; 1=moving left
    sta player_moving

    player_move_not_left:
    clc
    
    ldx #189        ; (X)
    jsr check_key
    cpy #255
    bne player_move_not_right
    clc
    
;    player_move_right_wait:
;        ldx #189        ; (X)
;        jsr check_key
;        cpy #255
;        beq player_move_right_wait
;    clc
    
    lda scroll_offset_low
    cmp #$58
    bne player_move_move_right
    lda scroll_offset_high
    cmp #$01
    bne player_move_move_right
    
    clc
    rts
    
    player_move_move_right:
    
    jsr player_move_right   ; allow the player to jump while moving
    
    lda #2                  ; 2=moving right
    sta player_moving

    player_move_not_right:
    
    lda player_jumping
    cmp #0
    bne player_move_not_jump
    
    ldx #182        ; (Return)
    jsr check_key
    cpy #255
    bne player_move_not_jump
    clc
    
    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot
    
    jsr player_jump
    
    jsr plot_player                 ; plot
    
    player_move_not_jump:
    
    clc
    rts

scroll_right_update:

    lda bank_number
    cmp #2              ; showing bank 2?
    beq scroll_right_update_show_bank1
    
    jsr plot_bank2r
    lda #19
    jsr $fff4
    jsr show_bank2
    
    jsr scroll_update_bank1_bank2
    
    lda player_animation
    ora #$02
    sta player_animation
    
    jsr plot_char_bank2 ; plot the player on bank 2
    
    clc
    rts
    
    scroll_right_update_show_bank1:
    clc
    
    jsr scroll_right
    
    lda $80
    adc #1
    sta $80
    lda $81
    adc #0
    sta $81
    clc
    
    jsr plot_bank1r
    lda #19
    jsr $fff4
    jsr show_bank1
    
    jsr scroll_update_bank2_bank1
    
    lda player_animation
    ora #$02
    sta player_animation
    
    jsr plot_char_bank1 ; plot the player on bank 1
    
    clc
    rts

scroll_left_update:

    lda bank_number
    cmp #2              ; showing bank 2?
    beq scroll_left_update_show_bank1
    
    jsr plot_bank2l
    lda #19
    jsr $fff4
    jsr show_bank2
    
    jsr scroll_update_bank1_bank2
    
    lda player_animation
    and #$01
    sta player_animation
    
    jsr plot_char_bank2 ; plot the player on bank 2
    
    clc
    rts
    
    scroll_left_update_show_bank1:
    clc
    
    jsr scroll_left
    
    lda $80
    sec
    sbc #1
    sta $80
    lda $81
    sbc #0
    sta $81
    clc
    
    jsr plot_bank1l
    lda #19
    jsr $fff4
    jsr show_bank1
    
    jsr scroll_update_bank2_bank1
    
    lda player_animation
    and #$01
    sta player_animation
    
    jsr plot_char_bank1 ; plot the player on bank 1
    
    clc
    rts

scroll_update_bank2_bank1:

    jsr plot_char_bank2 ; unplot the player on bank 2
    
    lda player_animation
    eor #1
    sta player_animation
    
    lda player_falling
    cmp #0
    beq scroll_update_plot_bank1
    
    inc player_y
    
    scroll_update_plot_bank1:
    clc
    
    lda #1
    sta bank_number
    
    clc
    rts

scroll_update_bank1_bank2:

    jsr plot_char_bank1 ; unplot the player on bank 1
    
    lda player_falling
    cmp #0
    beq scroll_update_plot_bank2
    
    inc player_y
    
    scroll_update_plot_bank2:
    clc
    
    lda #2
    sta bank_number
    
    clc
    rts

check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jsr $fff4
    rts

check_beneath:

    lda player_y
    cmp #13
    bpl check_beneath_exit
    
    adc #3
    sta $71
    lda player_x
    sta $70
    
    jsr check_tile
    cmp #0
    bne check_beneath_exit
    
    clc
    inc $70
    jsr check_tile
    cmp #0
    bne check_beneath_exit
    
    lda bank_number
    cmp #2
    bne check_beneath_fall
    
    clc
    inc $70
    jsr check_tile
    cmp #0
    bne check_beneath_exit
    
    check_beneath_fall:
    
    lda #1
    sta player_falling
    clc
    rts
    
    check_beneath_exit:
    lda #0
    sta player_falling
    clc
    rts

clear_bank1:

    lda #$00
    sta $70
    lda #$30
    sta $71
    ldy #0
    
    clear_bank1_loop:
    
        lda #0
        sta ($70),y
        
        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc
        
        cmp #$58
        bne clear_bank1_loop
    
    clc
    rts

clear_bank2:

    lda #$00
    sta $70
    lda #$58
    sta $71
    ldy #0
    
    clear_bank2_loop:
    
        lda #0
        sta ($70),y
        
        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc
        
        cmp #$80
        bne clear_bank2_loop
    
    clc
    rts

show_bank1:

    lda #$00
    sta $fe02
    lda #$18
    sta $fe03
    clc
    rts

show_bank2:

    lda #$00
    sta $fe02
    lda #$2c
    sta $fe03
    clc
    rts

set_core_palette:

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    rts

set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $3dfb
    lda $71
    sta $3dfc
    lda #0
    sta $3dfd
    sta $3dfe
    sta $3dff

    lda #$c         
    ldx #$fb
    ldy #$3d
    jsr $fff1
    rts

bank1_rows_low:  .byte  $00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0
bank1_rows_high: .byte  $3a,$3b,$3c,$3d,$3f,$40,$41,$42,$44,$45,$46,$47,$49,$4a,$4b,$4c
bank2_rows_low:  .byte  $00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0
bank2_rows_high: .byte  $62,$63,$64,$65,$67,$68,$69,$6a,$6c,$6d,$6e,$6f,$71,$72,$73,$74

init_scrolling:

    ldx #15
    init_banks_loop:
    
        lda #0
        sta row_indices,x
        sta initial_row_tiles,x
        sta initial_row_offsets,x
        sta max_row_offsets,x
        dex
        bpl init_banks_loop
    
    clc
    rts

plot_bank1r:

    ldx #15          ; row number
    
    plot_bank1r_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.

        cmp #40
        bcc plot_bank1r_row_loop_calculate_row_address
        
        dex
        bpl plot_bank1r_row_loop     ; Loop again or exit.
        clc
        rts
        
        plot_bank1r_row_loop_calculate_row_address:
        
        sta $74
        asl                     ; Multiply o by 8
        asl
        asl
        sta $72
        lda #0
        adc #0
        sta $73
        clc
        
        lda $72
        adc bank1_rows_low,x    ; Add to the screen start address for the
        sta $72                 ; row, R, to get x.
        lda $73
        adc bank1_rows_high,x
        sta $73                 ; x ($72,$73)
        clc
        
        plot_bank1r_offset_loop:
        
            ldy #0
            lda ($76),y             ; Load the type number, t,
            and #$0f                ; mask off the top 4 bits,
            asl                     ; multiply by 8 to get t1.
            asl
            asl
            adc #sprite_area_low    ; add to S to get S1.
            sta $70
            lda #sprite_area_high
            adc #0
            sta $71                 ; S1 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            adc #1              ; n
            bcs plot_bank1r_offset_endloop
            
            tay                 ; temp (n)
            adc $74             ; Add n to o.
            clc
            
            cmp #40
            bcs plot_bank1r_offset_endloop
            sta $74

            tya                 ; temp (n)
            asl
            asl
            asl                 ; n*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73             ; x ($72,$73)
            clc
            
            lda $76             ; Add 2 to I.
            adc #2
            sta $76
            bcc plot_bank1r_offset_loop
            
            lda $77
            adc #0
            sta $77
            clc
            
            jmp plot_bank1r_offset_loop
        
        plot_bank1r_offset_endloop:
        clc
        
        dex
        bmi plot_bank1r_row_endloop
        jmp plot_bank1r_row_loop
    
    plot_bank1r_row_endloop:
    clc
    rts

plot_bank1l:

    ldx #15          ; row number
    
    plot_bank1l_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.
        sec
        sbc #1
        clc

        cmp #40
        bcc plot_bank1l_row_loop_calculate_row_address
        
        dex
        bpl plot_bank1l_row_loop     ; Loop again or exit.
        clc
        rts
        
        plot_bank1l_row_loop_calculate_row_address:
        
        sta $74
        asl                     ; Multiply o by 8
        asl
        asl
        sta $72
        lda #0
        adc #0
        sta $73
        clc
        
        lda $72
        adc bank1_rows_low,x    ; Add to the screen start address for the
        sta $72                 ; row, R, to get x.
        lda $73
        adc bank1_rows_high,x
        sta $73                 ; x ($72,$73)
        clc
        
        lda initial_row_tiles,x     ; Load the initial tile type.
        
        asl                     ; multiply by 8 to get t1.
        asl
        asl
        adc #sprite_area_low    ; add to S to get S1.
        sta $70
        lda #sprite_area_high
        adc #0
        sta $71                 ; S1 ($70,$71)
        clc
        
        plot_bank1l_offset_loop:
        
            jsr plot_tile_bank
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            adc #1              ; n
            bcs plot_bank1l_offset_endloop
            
            tay                 ; temp (n)
            adc $74             ; Add n to o.
            clc
            
            cmp #40
            bcs plot_bank1l_offset_endloop
            sta $74

            tya                 ; temp (n)
            asl
            asl
            asl                 ; n*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73             ; x ($72,$73)
            clc
            
            ldy #0
            lda ($76),y             ; Load the type number, t,
            and #$0f                ; mask off the top 4 bits,
            asl                     ; multiply by 8 to get t1.
            asl
            asl
            adc #sprite_area_low    ; add to S to get S1.
            sta $70
            lda #sprite_area_high
            adc #0
            sta $71                 ; S1 ($70,$71)
            clc
            
            lda $76             ; Add 2 to I.
            adc #2
            sta $76
            bcc plot_bank1l_offset_loop
            
            lda $77
            adc #0
            sta $77
            clc
            
            jmp plot_bank1l_offset_loop
        
        plot_bank1l_offset_endloop:
        clc
        
        dex
        bmi plot_bank1l_row_endloop
        jmp plot_bank1l_row_loop
    
    plot_bank1l_row_endloop:
    clc
    rts

plot_tile_bank:     ; $70,$71 source address
                    ; $72,$73 screen address

    ldy #7
    plot_tile_bank_loop:
    
        lda ($70),y
        sta ($72),y
        dey
        bpl plot_tile_bank_loop
    
    clc
    rts

scroll_right:

    ldx #15
    scroll_right_loop:
    
        lda initial_row_offsets,x
        cmp #0
        beq scroll_right_loop_next_offset
        
        dec initial_row_offsets,x
        
        dex
        bpl scroll_right_loop
        
        clc
        rts
        
        scroll_right_loop_next_offset:
        clc
        
        jsr read_row_address    ; read the row address before we update the index
        
        inc row_indices,x   ; increment the index to refer to the next span
        
        ldy #0
        lda ($76),y             ; load the tile type for the current span
        and #$0f
        sta initial_row_tiles,x ; store the tile type
        
        ldy #1              ; load the number of tiles left in the current span
        lda ($76),y         ; minus 1 (n - 1)
        sta initial_row_offsets,x
        sta max_row_offsets,x
        
        dex
        bpl scroll_right_loop
    
    clc
    rts

scroll_left:

    ldx #15
    scroll_left_loop:
    
        lda initial_row_offsets,x
        cmp max_row_offsets,x
        beq scroll_left_loop_previous_offset
        
        inc initial_row_offsets,x
        
        dex
        bpl scroll_left_loop
        
        clc
        rts
        
        scroll_left_loop_previous_offset:
        clc
        
        dec row_indices,x   ; decrement the index to refer to the previous span
        
        jsr read_row_address    ; read the row address for the previous span
        
        lda $76             ; refer to the span before the previous span, p'
        sec
        sbc #2
        sta $76
        lda $77
        sbc #0
        sta $77
        clc
        
        ldy #0
        lda ($76),y             ; load the tile type for span p'
        and #$0f
        sta initial_row_tiles,x ; store the tile type
        
        ldy #1                  ; load the number of tiles in span p'
        lda ($76),y             ; minus 1 (n - 1)
        sta max_row_offsets,x   ; store this value as the maximum row offset
                                ; for the previous span
        
        lda #0
        sta initial_row_offsets,x   ; set the initial row offset of the previous
                                    ; span
        
        dex
        bpl scroll_left_loop
    
    clc
    rts

plot_bank2r:

    ldx #15          ; row number
    
    plot_bank2r_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.
        cmp #41
        bcc plot_bank2r_row_loop_calculate_row_address
        
        dex
        bpl plot_bank2r_row_loop
        clc
        rts
        
        plot_bank2r_row_loop_calculate_row_address:
        
        sta $74
        asl                     ; Multiply o by 8
        asl
        asl
        sta $72
        lda #0
        adc #0
        sta $73
        clc
        
        lda $72
        adc bank2_rows_low,x    ; Add to the screen start address for the
        sta $72                 ; row, R, to get x.
        lda $73
        adc bank2_rows_high,x
        sta $73                 ; x ($72,$73)
        clc
        
        lda $74
        cmp #0
        beq plot_bank2r_row_loop_skip_leading
        cmp #40
        bmi plot_bank2r_row_loop_plot_leading
        
        dex
        bpl plot_bank2r_row_loop
        clc
        rts
        
        plot_bank2r_row_loop_plot_leading:
        
        lda $72                 ; move to the previous cell
        sec
        sbc #8
        sta $72
        lda $73
        sbc #0
        sta $73
        clc
        
        ldy #0
        lda ($76),y                 ; Load the type number, t,
        and #$f0                    ; mask off the bottom 4 bits,
        lsr                         ; divide by 2 to get t2.
        adc #merged_sprites_low     ; add to S to get S2.
        sta $70
        lda #merged_sprites_high
        adc #0
        sta $71                     ; S2 ($70,$71)
        clc
        
        jsr plot_tile_bank
        
        lda $72                 ; move to the next cell
        adc #8
        sta $72
        lda $73
        adc #0
        sta $73
        clc
        
        plot_bank2r_row_loop_skip_leading:
        clc
        
        plot_bank2r_offset_loop:
        
            ldy #1
            lda ($76),y                 ; Load the number of tiles minus 1, n - 1.
            sta $79                     ; temp (n - 1)
            cmp #0                      ; If there is only one tile in the
            beq plot_bank2r_offset_next  ; span, move to the next span,
                                        ; otherwise plot a continuation tile.
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$0f                    ; mask off the top 4 bits,
            asl                         ; multiply by 8 to get t1.
            asl
            asl
            adc #rotated_sprites_low    ; add to SR to get S3.
            sta $70
            lda #rotated_sprites_high
            adc #0
            sta $71                     ; S3 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            lda $74
            adc $79                 ; Add n - 1 to o.
            clc
            
            cmp #40
            bcs plot_bank2r_offset_endloop   ; break if the screen edge is reached
            sta $74                 ; Store the new offset
            
            lda $79                 ; n - 1
            asl
            asl
            asl                     ; (n - 1)*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73                 ; x ($72,$73)
            clc
            
            plot_bank2r_offset_next:
            clc
            
            lda $76                 ; Add 2 to I.
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$f0                    ; mask off the bottom 4 bits,
            lsr                         ; divide by 2 to get t2.
            adc #merged_sprites_low     ; add to S to get S2.
            sta $70
            lda #merged_sprites_high
            adc #0
            sta $71                     ; S2 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            lda $72                 ; move to the next cell
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc
            
            inc $74
            
            lda $74
            cmp #40
            bcs plot_bank2r_offset_endloop   ; break if the screen edge is reached

            jmp plot_bank2r_offset_loop
        
        plot_bank2r_offset_endloop:
        clc
        
        dex
        bmi plot_bank2r_row_endloop
        jmp plot_bank2r_row_loop
    
    plot_bank2r_row_endloop:
    clc
    rts

plot_bank2l:

    ldx #15          ; row number
    
    plot_bank2l_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.
        cmp #42
        bcc plot_bank2l_row_loop_calculate_row_address
        
        dex
        bpl plot_bank2l_row_loop
        clc
        rts
        
        plot_bank2l_row_loop_calculate_row_address:
        
        sec                     ; Each full tile starts two cells before the
        sbc #2                  ; tiles that arrive from the right.
        sta $74
        clc
        
        asl                     ; Multiply o by 8
        asl
        asl
        sta $72
        lda #0
        adc #0
        sta $73
        clc
        
        lda $72
        adc bank2_rows_low,x    ; Add to the screen start address for the
        sta $72                 ; row, R, to get x.
        lda $73
        adc bank2_rows_high,x
        sta $73                 ; x ($72,$73)
        clc
        
        lda $74
        cmp #0
        bcc plot_bank2l_skip_leading_tile
        
        clc
        
        lda initial_row_tiles,x     ; Load the initial tile type.
        
        asl                     ; multiply by 8 to get t1.
        asl
        asl
        adc #rotated_sprites_low    ; add to S to get S1.
        sta $70
        lda #rotated_sprites_high
        adc #0
        sta $71                 ; S1 ($70,$71)
        clc
        
        jsr plot_tile_bank
        
        plot_bank2l_skip_leading_tile:
        clc
        
        plot_bank2l_offset_loop:
        
            inc $74
            
            lda $74
            cmp #40
            bcs plot_bank2l_offset_endloop   ; break if the screen edge is reached
            
            lda $72                 ; move to the next cell
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc
            
            lda $76                 ; Add 2 to I.
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$f0                    ; mask off the bottom 4 bits,
            lsr                         ; divide by 2 to get t2.
            adc #merged_sprites_low     ; add to S to get S2.
            sta $70
            lda #merged_sprites_high
            adc #0
            sta $71                     ; S2 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            ldy #1
            lda ($76),y                 ; Load the number of tiles minus 1, n - 1.
            sta $79                     ; temp (n - 1)
            cmp #0                      ; If there is only one tile in the
            beq plot_bank2l_offset_next  ; span, move to the next span,
                                        ; otherwise plot a continuation tile.
            
            lda $74
            adc $79                 ; Add n - 1 to o.
            clc
            
            cmp #40
            bcs plot_bank2l_offset_endloop   ; break if the screen edge is reached
            sta $74                 ; Store the new offset
            
            lda $79                 ; n - 1
            asl
            asl
            asl                     ; (n - 1)*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73                 ; x ($72,$73)
            clc
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$0f                    ; mask off the top 4 bits,
            asl                         ; multiply by 8 to get t1.
            asl
            asl
            adc #rotated_sprites_low    ; add to SR to get S3.
            sta $70
            lda #rotated_sprites_high
            adc #0
            sta $71                     ; S3 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            plot_bank2l_offset_next:
            clc
            
            jmp plot_bank2l_offset_loop
        
        plot_bank2l_offset_endloop:
        clc
        
        dex
        bmi plot_bank2l_row_endloop
        jmp plot_bank2l_row_loop
    
    plot_bank2l_row_endloop:
    clc
    rts

read_row_address:           ; X=row number
                            ; Returns $76,$77 (row address)

    lda row_table_low,x     ; Load entry a from the table.

    adc #level_data_low     ; Add a to the data start address
                            ; to get the row start address, A.
    sta $76
    lda row_table_high,x
    adc #level_data_high
    sta $77             ; A ($76,$77)
    clc

    lda row_indices,x   ; Load index i from the indices;
    asl                 ; and multiply it by 2 to get i*2.
    adc $76             ; Add i*2 to A to get the address, I, of the
    sta $76             ; starting offset and type.
    lda $77
    adc #0
    sta $77             ; I ($76,$77)
    clc
    
    rts

initial_plot_bank1:

    ldx #15
    initial_plot_bank1_row_loop:
    
        clc
        jsr read_row_address
        
        lda bank1_rows_low,x
        sta $72
        lda bank1_rows_high,x
        sta $73                 ; x ($72,$73)
        
        lda #0
        sta $74
        
        initial_plot_bank1_span_loop:
        
            ldy #0
            lda ($76),y             ; Load the type number, t,
            and #$0f                ; mask off the top 4 bits,
            asl                     ; multiply by 8 to get t1.
            asl
            asl
            adc #sprite_area_low    ; add to S to get S1.
            sta $70
            lda #sprite_area_high
            adc #0
            sta $71                 ; S1 ($70,$71)
            clc
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            sta $78
            
            initial_plot_bank1_tile_loop:
            
                jsr plot_tile_bank
                
                lda $72
                adc #8
                sta $72
                lda $73
                adc #0
                sta $73
                clc
                
                inc $74         ; one tile filled on the screen
                
                lda $74
                cmp #40
                beq initial_plot_bank1_span_endloop
                lda $78
                cmp #0
                beq initial_plot_bank1_tile_endloop
                
                dec $78         ; one tile less to plot
                
                jmp initial_plot_bank1_tile_loop
            
            initial_plot_bank1_tile_endloop:
            clc
            
            lda $74
            cmp #40
            beq initial_plot_bank1_span_endloop
            clc
            
            lda $76
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            jmp initial_plot_bank1_span_loop
        
        initial_plot_bank1_span_endloop:
        clc
        
        dex
        bpl initial_plot_bank1_row_loop
    
    clc
    rts

initial_plot_bank2:

    ldx #15
    initial_plot_bank2_row_loop:
    
        clc
        jsr read_row_address
        
        lda bank2_rows_low,x
        sta $72
        lda bank2_rows_high,x
        sta $73                 ; x ($72,$73)
        
        lda #0
        sta $74
        
        initial_plot_bank2_span_loop:
        
            lda $74
            cmp #0
            beq initial_plot_bank2_span_loop_skip_merged
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$f0                    ; mask off the bottom 4 bits,
            lsr                         ; divide by 2 to get t2.
            adc #merged_sprites_low     ; add to S to get S2.
            sta $70
            lda #merged_sprites_high
            adc #0
            sta $71                     ; S2 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            lda $72
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc
            
            inc $74         ; one tile filled on the screen
            
            initial_plot_bank2_span_loop_skip_merged:
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$0f                    ; mask off the top 4 bits,
            asl                         ; multiply by 8 to get t1.
            asl
            asl
            adc #rotated_sprites_low    ; add to SR to get S3.
            sta $70
            lda #rotated_sprites_high
            adc #0
            sta $71                     ; S3 ($70,$71)
            clc
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            sta $78
            
            initial_plot_bank2_tile_loop:
            
                lda $74
                cmp #40
                beq initial_plot_bank2_span_endloop
                lda $78
                cmp #0
                beq initial_plot_bank2_tile_endloop
                
                jsr plot_tile_bank
                
                lda $72
                adc #8
                sta $72
                lda $73
                adc #0
                sta $73
                clc
                
                inc $74         ; one tile filled on the screen
                dec $78         ; one tile less to plot
                
                jmp initial_plot_bank2_tile_loop
            
            initial_plot_bank2_tile_endloop:
            clc
            
            lda $74
            cmp #40
            beq initial_plot_bank2_span_endloop
            clc
            
            lda $76
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            jmp initial_plot_bank2_span_loop
        
        initial_plot_bank2_span_endloop:
        clc
        
        dex
        bmi initial_plot_bank2_row_endloop
        jmp initial_plot_bank2_row_loop
    
    initial_plot_bank2_row_endloop:
    clc
    rts

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c

plot8x24_y0:            ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #2

    plot8x24_y0_loop:

        ldy #15

        plotloop8x24_y0_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y0_0

        dex
        bmi plot8x24_y0_exit
        
        lda $72
        adc #$40
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        lda $70
        adc #16
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        jmp plot8x24_y0_loop

    plot8x24_y0_exit:
    clc
    rts

player_sprites_low:  .byte <char_area, <[char_area + 48], <[char_area + 96], <[char_area + 144]
player_sprites_high: .byte >char_area, >[char_area + 48], >[char_area + 96], >[char_area + 144]

plot_char_bank1:            ; plots the player character on bank 1

    ldx player_animation
    lda player_sprites_low,x
    sta $70
    lda player_sprites_high,x
    sta $71
    
    ldx player_y
    lda player_x
    asl
    asl
    asl
    adc bank1_rows_low,x
    sta $72
    lda bank1_rows_high,x
    adc #0
    sta $73
    clc
    
    jmp plot8x24_y0
    
plot_char_bank2:            ; plots the player character on bank 2

    ldx player_animation
    lda player_sprites_low,x
    sta $70
    lda player_sprites_high,x
    sta $71
    
    ldx player_y
    lda player_x
    asl
    asl
    asl
    adc bank2_rows_low,x
    sta $72
    lda bank2_rows_high,x
    adc #0
    sta $73
    clc
    
    jmp plot8x24_y0

plot_player:

    lda bank_number
    cmp #1
    bne plot_player_plot_bank2
    
        clc
        jmp plot_char_bank1
    
    plot_player_plot_bank2:
    
        clc
        jmp plot_char_bank2

check_tile:         ; $70=x position (0-39)
                    ; $71=y position (0-15)

    ldx $71
    jsr read_row_address
    
    lda initial_row_offsets,x
    cmp $70
    beq check_tile_spans
    bmi check_tile_spans
    
    clc
    lda initial_row_tiles,x
    rts                     ; Return the type.
    
    check_tile_spans:
    clc
    
    sta $74                 ; Store the row offset of the next span.
    
    check_tile_spans_loop:
    
        ldy #1
        lda ($76),y         ; Load the number of tiles minus 1, n - 1.
        adc #1              ; n
        adc $74             ; Add to the row offset
        clc
        
        cmp $70
        beq check_tile_spans_loop_next
        bmi check_tile_spans_loop_next
        
        clc
        ldy #0
        lda ($76),y             ; Load the type number, t,
        and #$0f                ; mask off the top 4 bits,
        rts
        
        check_tile_spans_loop_next:
        
        cmp #40
        bpl check_tile_spans_endloop
        
        sta $74             ; and store the result.
        
        lda $76             ; Increment the row address.
        adc #2
        sta $76
        lda $77
        adc #0
        sta $77
        clc
        
        jmp check_tile_spans_loop
        
    check_tile_spans_endloop:
    clc
    
    lda #0          ; In theory, we should never reach here.
    rts

check_move_right:

    lda player_x
    adc #2
    sta $70
    lda player_y
    sta $71
    clc
    
    jmp check_move  ; branch then exit

player_move_right:

    clc
    jsr check_move_right
    bcs player_move_right_cannot_move
    
    jmp scroll_right_update     ; branch then exit
    
    player_move_right_cannot_move:
    
    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

check_move_left:

    lda player_x
    sec
    sbc #2
    sta $70
    lda player_y
    sta $71
    clc
    
    ; fall through into the next routine

check_move:

    lda #2
    sta $72
    
    lda player_falling
    cmp #0
    beq check_move_loop
    
    inc $72         ; If the player is falling then we need to check an
                    ; additional tile.
    
    check_move_loop:
    
        clc
        jsr check_tile
        cmp #0
        beq check_move_next
        sec
        rts
        
        check_move_next:
        
        inc $71
        dec $72
        bpl check_move_loop
    
    clc
    rts

player_move_left:

    clc
    jsr check_move_left
    bcs player_move_left_cannot_move
    
    jmp scroll_left_update     ; branch then exit
    
    player_move_left_cannot_move:
    
    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

jump_steps: .byte 2,1,1,0
char_plot_routines: .byte 0,0,<plot_char_bank1,>plot_char_bank1,<plot_char_bank2,>plot_char_bank2

player_jump:

    clc
    
    ldx player_jumping
    lda jump_steps,x
    sta $72
    
    lda player_y
    sta $71
    
    player_jump_check_loop:
    
        lda $72
        cmp #0
        beq player_jump_check_endloop
        
        lda $71
        cmp #0
        beq player_jump_stop_jumping
        dec $71
        clc
        
        lda player_x
        sta $70
        jsr check_tile
        cmp #0
        bne player_jump_stop_jumping
        clc
        
        inc $70
        
        jsr check_tile
        cmp #0
        bne player_jump_stop_jumping
        
        lda $71
        sta player_y
        
        dec $72
        jmp player_jump_check_loop
    
    player_jump_check_endloop:
    clc
    
    lda player_jumping
    adc #1
    cmp #4
    bpl player_jump_stop_jumping
    
    sta player_jumping
    clc
    rts
    
    player_jump_stop_jumping:
    clc
    
    lda #0
    sta player_jumping
    
    clc
    rts

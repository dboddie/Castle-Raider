.org $0e00

.include "constants.oph"

init:

    lda #22         ; MODE 5
    jsr $ffee
    lda #5
    jsr $ffee

    lda #23         ; disable flashing cursor
    jsr $ffee
    lda #1
    jsr $ffee
    ldx #7
    cursor_loop:
        lda #0
        jsr $ffee
        dex
        bpl cursor_loop
    
    jsr set_core_palette

main:

    jsr clear_bank1
    jsr clear_bank2
    
    jsr show_bank1
    
    jsr init_scrolling
    
    pre_scroll_loop:
    
        clc
        
        jsr plot_bank2
        lda #19
        jsr $fff4
        jsr show_bank2
        
        jsr pre_scroll_right
        clc
        
        jsr plot_bank1
        lda #19
        jsr $fff4
        jsr show_bank1
        
        ldx #0
        lda initial_row_offsets,x
        cmp #0
        bne pre_scroll_loop
    
    clc
    lda #0
    sta $80
    
    scroll_loop:
    
        jsr plot_bank2
        lda #19
        jsr $fff4
        jsr show_bank2
        
        jsr scroll_right
        
        jsr plot_bank1
        lda #19
        jsr $fff4
        jsr show_bank1
        
        lda $80
        adc #1
        sta $80
        cmp #152
        beq scroll_loop_endloop
        jmp scroll_loop
    
    scroll_loop_endloop:
    
    clc
    rts

check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jsr $fff4
    rts

clear_bank1:

    lda #$00
    sta $70
    lda #$30
    sta $71
    ldy #0
    
    clear_bank1_loop:
    
        lda #0
        sta ($70),y
        
        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc
        
        cmp #$58
        bne clear_bank1_loop
    
    clc
    rts

clear_bank2:

    lda #$00
    sta $70
    lda #$58
    sta $71
    ldy #0
    
    clear_bank2_loop:
    
        lda #0
        sta ($70),y
        
        lda $70
        adc #1
        sta $70
        lda $71
        adc #0
        sta $71
        clc
        
        cmp #$80
        bne clear_bank2_loop
    
    clc
    rts

show_bank1:

    lda #$00
    sta $fe02
    lda #$18
    sta $fe03
    clc
    rts

show_bank2:

    lda #$00
    sta $fe02
    lda #$2c
    sta $fe03
    clc
    rts

set_core_palette:

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    rts

set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $3dfb
    lda $71
    sta $3dfc
    lda #0
    sta $3dfd
    sta $3dfe
    sta $3dff

    lda #$c         
    ldx #$fb
    ldy #$3d
    jsr $fff1
    rts

.alias row_indices          $1fc0
.alias initial_row_offsets  $1fd0
.alias row_table_low        $1fe0
.alias row_table_high       $1ff0
.alias level_data_low       $00
.alias level_data_high      $20

bank1_rows_low:  .byte  $00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0
bank1_rows_high: .byte  $3a,$3b,$3c,$3d,$3f,$40,$41,$42,$44,$45,$46,$47,$49,$4a,$4b,$4c
bank2_rows_low:  .byte  $00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0
bank2_rows_high: .byte  $62,$63,$64,$65,$67,$68,$69,$6a,$6c,$6d,$6e,$6f,$71,$72,$73,$74

init_scrolling:

    ldx #15
    init_banks_loop:
    
        lda #0
        sta row_indices,x
        lda #40
        sta initial_row_offsets,x
        dex
        bpl init_banks_loop
    
    clc
    rts

plot_bank1:

    ldx #15          ; row number
    
    plot_bank1_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.

        cmp #40
        bcc plot_bank1_row_loop_calculate_row_address
        
        dex
        bpl plot_bank1_row_loop     ; Loop again or exit.
        clc
        rts
        
        plot_bank1_row_loop_calculate_row_address:
        
        sta $74
        asl                     ; Multiply o by 8
        asl
        asl
        sta $72
        lda #0
        adc #0
        sta $73
        clc
        
        lda $72
        adc bank1_rows_low,x    ; Add to the screen start address for the
        sta $72                 ; row, R, to get x.
        lda $73
        adc bank1_rows_high,x
        sta $73                 ; x ($72,$73)
        clc
        
        plot_bank1_offset_loop:
        
            ldy #0
            lda ($76),y             ; Load the type number, t,
            and #$0f                ; mask off the top 4 bits,
            asl                     ; multiply by 8 to get t1.
            asl
            asl
            adc #sprite_area_low    ; add to S to get S1.
            sta $70
            lda #sprite_area_high
            adc #0
            sta $71                 ; S1 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            ldy #1
            lda ($76),y         ; Load the number of tiles minus 1, n - 1.
            adc #1              ; n
            bcs plot_bank1_offset_endloop
            
            tay                 ; temp (n)
            adc $74             ; Add n to o.
            clc
            
            cmp #40
            bcs plot_bank1_offset_endloop
            sta $74

            tya                 ; temp (n)
            asl
            asl
            asl                 ; n*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73             ; x ($72,$73)
            clc
            
            lda $76             ; Add 2 to I.
            adc #2
            sta $76
            bcc plot_bank1_offset_loop
            
            lda $77
            adc #0
            sta $77
            clc
            
            jmp plot_bank1_offset_loop
        
        plot_bank1_offset_endloop:
        clc
        
        dex
        bmi plot_bank1_row_endloop
        jmp plot_bank1_row_loop
    
    plot_bank1_row_endloop:
    clc
    rts

plot_tile_bank:     ; $70,$71 source address
                    ; $72,$73 screen address

    ldy #7
    plot_tile_bank_loop:
    
        lda ($70),y
        sta ($72),y
        dey
        bpl plot_tile_bank_loop
    
    clc
    rts

pre_scroll_right:

    ldx #15
    pre_scroll_right_loop:
    
        lda initial_row_offsets,x
        cmp #0
        beq pre_scroll_right_loop_not_next_offset
        
        dec initial_row_offsets,x
        
        pre_scroll_right_loop_not_next_offset:
        dex
        bpl pre_scroll_right_loop
    
    clc
    rts

scroll_right:

    ldx #15
    scroll_right_loop:
    
        lda initial_row_offsets,x
        cmp #0
        beq scroll_right_loop_next_offset
        
        dec initial_row_offsets,x
        
        dex
        bpl scroll_right_loop
        
        clc
        rts
        
        scroll_right_loop_next_offset:
        clc
        
        jsr read_row_address
        
        inc row_indices,x   ; increment the index
        
        ldy #1              ; load the number of tiles left in the current span
        lda ($76),y         ; minus 1 (n - 1)
        sta initial_row_offsets,x
        
        dex
        bpl scroll_right_loop
    
    clc
    rts

plot_bank2:

    ldx #15          ; row number
    
    plot_bank2_row_loop:
    
        clc
        jsr read_row_address
        
        lda initial_row_offsets,x   ; Load the initial row offset, o.
        cmp #41
        bcc plot_bank2_row_loop_calculate_row_address
        
        dex
        bpl plot_bank2_row_loop
        clc
        rts
        
        plot_bank2_row_loop_calculate_row_address:
        
        sta $74
        asl                     ; Multiply o by 8
        asl
        asl
        sta $72
        lda #0
        adc #0
        sta $73
        clc
        
        lda $72
        adc bank2_rows_low,x    ; Add to the screen start address for the
        sta $72                 ; row, R, to get x.
        lda $73
        adc bank2_rows_high,x
        sta $73                 ; x ($72,$73)
        clc
        
        lda $74
        cmp #0
        beq plot_bank2_row_loop_skip_leading
        cmp #40
        bmi plot_bank2_row_loop_plot_leading
        
        dex
        bpl plot_bank2_row_loop
        clc
        rts
        
        plot_bank2_row_loop_plot_leading:
        
        lda $72                 ; move to the previous cell
        sec
        sbc #8
        sta $72
        lda $73
        sbc #0
        sta $73
        clc
        
        ldy #0
        lda ($76),y                 ; Load the type number, t,
        and #$f0                    ; mask off the bottom 4 bits,
        lsr                         ; divide by 2 to get t2.
        adc #merged_sprites_low     ; add to S to get S2.
        sta $70
        lda #merged_sprites_high
        adc #0
        sta $71                     ; S2 ($70,$71)
        clc
        
        jsr plot_tile_bank
        
        lda $72                 ; move to the next cell
        adc #8
        sta $72
        lda $73
        adc #0
        sta $73
        clc
        
        plot_bank2_row_loop_skip_leading:
        clc
        
        lda $74
        cmp #40
        bmi plot_bank2_offset_loop
        
        dex
        bpl plot_bank2_row_loop
        clc
        rts
        
        plot_bank2_offset_loop:
        
            ldy #1
            lda ($76),y                 ; Load the number of tiles minus 1, n - 1.
            sta $79                     ; temp (n - 1)
            cmp #0                      ; If there is only one tile in the
            beq plot_bank2_offset_next  ; span, move to the next span,
                                        ; otherwise plot a continuation tile.
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$0f                    ; mask off the top 4 bits,
            asl                         ; multiply by 8 to get t1.
            asl
            asl
            adc #rotated_sprites_low    ; add to SR to get S3.
            sta $70
            lda #rotated_sprites_high
            adc #0
            sta $71                     ; S3 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            lda $74
            adc $79                 ; Add n - 1 to o.
            clc
            
            cmp #40
            bcs plot_bank2_offset_endloop   ; break if the screen edge is reached
            sta $74                 ; Store the new offset
            
            lda $79                 ; n - 1
            asl
            asl
            asl                     ; (n - 1)*8
            sta $7a
            lda #0
            adc #0
            sta $7b
            clc
            
            lda $72
            adc $7a
            sta $72
            lda $73
            adc $7b
            sta $73                 ; x ($72,$73)
            clc
            
            plot_bank2_offset_next:
            clc
            
            lda $76                 ; Add 2 to I.
            adc #2
            sta $76
            lda $77
            adc #0
            sta $77
            clc
            
            ldy #0
            lda ($76),y                 ; Load the type number, t,
            and #$f0                    ; mask off the bottom 4 bits,
            lsr                         ; divide by 2 to get t2.
            adc #merged_sprites_low     ; add to S to get S2.
            sta $70
            lda #merged_sprites_high
            adc #0
            sta $71                     ; S2 ($70,$71)
            clc
            
            jsr plot_tile_bank
            
            lda $72                 ; move to the next cell
            adc #8
            sta $72
            lda $73
            adc #0
            sta $73
            clc
            
            inc $74
            
            lda $74
            cmp #40
            bcs plot_bank2_offset_endloop   ; break if the screen edge is reached

            jmp plot_bank2_offset_loop
        
        plot_bank2_offset_endloop:
        clc
        
        dex
        bmi plot_bank2_row_endloop
        jmp plot_bank2_row_loop
    
    plot_bank2_row_endloop:
    clc
    rts

read_row_address:           ; X=row number
                            ; Returns $76,$77 (row address)

    lda row_table_low,x     ; Load entry a from the table.

    adc #level_data_low     ; Add a to the data start address
                            ; to get the row start address, A.
    sta $76
    lda row_table_high,x
    adc #level_data_high
    sta $77             ; A ($76,$77)
    clc

    lda row_indices,x   ; Load index i from the indices;
    asl                 ; and multiply it by 2 to get i*2.
    adc $76             ; Add i*2 to A to get the address, I, of the
    sta $76             ; starting offset and type.
    lda $77
    adc #0
    sta $77             ; I ($76,$77)
    clc
    
    rts

initial_plot_bank1:

    ldx #15
    initial_plot_bank1_row_loop:
    
        clc
        jsr read_row_address
        
        lda bank1_rows_low,x
        sta $72
        lda bank1_rows_high,x
        sta $73                 ; x ($72,$73)
        
        lda #0
        sta $74
        
        initial_plot_bank1_span_loop:
        
            

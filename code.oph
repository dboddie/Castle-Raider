; Copyright (C) 2013 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $0e00

.include "constants.oph"

.alias scrolled                         $7f
.alias scroll_offset_low                $8e
.alias scroll_offset_high               $8f

; Declare these here to make it easy to see that they are being used.
.alias tile_visibility_table_low        $82
.alias tile_visibility_table_high       $83
.alias special_tile_numbers_table_low   $84
.alias special_tile_numbers_table_high  $85
.alias monster_positions_table_low      $86
.alias monster_positions_table_high     $87

; Each monster type is defined as yyyyynnd.
.alias monster_data_axis_bit            $01
.alias monster_data_type_bits           $06

; Each monster visible type is defined as nnxa.
.alias monster_animation_bit            $01
.alias monster_dx_bit                   $02
.alias monster_type_bits                $0c
.alias monster_plot_bits                $0f
.alias monster_direction_bit            $20
.alias monster_axis_bit                 $40
.alias monster_existence_bit            $80

.alias monster_horizontal_motion        $00
.alias monster_vertical_motion          $40

; See the end of the file for included routines.

main:

    ; Set character's initial position and status.

    lda #19
    sta player_x
    lda #19
    sta player_y
    sta tracking_y      ; Set the vertical tracking position of the character.
    lda #0
    sta player_ys
    lda #2
    sta player_animation
    lda #0
    sta player_jumping
    sta player_moving
    sta player_falling
    lda #9
    sta player_lives
    lda #0
    sta player_lost

    ; Initialise the tile visibility values.

    ldx #31

    init_tile_visibility_loop:
        lda initial_tile_visibility_address,x
        sta tile_visibility_address,x
        dex
        bpl init_tile_visibility_loop
    clc

    ; Reset breakable tiles in the level.

    ldx #0
    lda row_table_low,x
    sta $76
    lda row_table_high,x
    sta $77

    ldy #0

    init_reset_tiles_loop:

        lda ($76),y                     ; Load the tile number.
        cmp #$80                        ; Skip anything higher than the
        bcs init_reset_tiles_next       ; breakable/broken tiles.

        init_reset_tiles_reset:

            cmp #$40                    ; Is the tile (partially) broken?
            bcc init_reset_tiles_write

            sbc #$18                    ; Unbreak it.
            jmp init_reset_tiles_reset

        init_reset_tiles_write:

        sta ($76),y                     ; Refresh/store the unbroken value.

        init_reset_tiles_next:
        clc

        lda $76
        adc #2
        sta $76
        lda $77
        adc #0
        sta $77
        clc

        cmp #monster_row_address_high   ; At the end of the tile data?
        bne init_reset_tiles_loop

        lda $76
        cmp #monster_row_address_low    ; At the end of the tile data?
        bne init_reset_tiles_loop

    clc

    ; Determine the left and right monster indices and offsets.

    lda #0
    sta monster_movement_counter

    ; Initialise the monster positions.

    ldx #15
    lda #0

    init_monster_positions_loop:
        sta monster_positions_address,x
        dex
        bpl init_monster_positions_loop

    jsr clear_bank1
    jsr clear_bank2

    jsr init_scrolling

    jsr show_bank2          ; Hide the bank being plotted.
    jsr initial_plot_bank1
    jsr plot_char_bank1
    jsr plot_monsters_bank1 ; Show any initial monsters.
    jsr show_bank1          ; Show the completed bank.
    jsr initial_plot_bank2

    lda #0                  ; Set the initial scroll offset and tracking offset.
    sta scroll_offset_low
    sta tracking_low
    lda #0
    sta scroll_offset_high
    sta tracking_high

    main_loop:

        lda #0
        sta scrolled

        main_loop_check_lost:

        lda player_lost
        cmp #0
        beq main_loop_check_jump

            lda player_lives
            cmp #0
            beq main_loop_endloop

            jsr track_position      ; Move the player back to the tracking position.
            bcs main_loop_next

            lda #0
            sta player_lost

            lda tracking_y
            sta player_y

            jsr plot_char           ; Plot the character again.

        main_loop_check_jump:

        lda player_jumping          ; Is the character jumping?
        cmp #0                      ; If so then check for input, which might.
        bne main_loop_allow_movement ; be ignored.

            jsr check_beneath       ; If not, then check below the character.

        main_loop_check_fall:

        lda player_falling          ; Is the character falling?
        cmp #0
        beq main_loop_allow_movement

            jsr player_fall         ; Yes, so move them downwards.
            bcs main_loop_next      ; If they are moving horizontally then skip
                                    ; past the movement checks.
        main_loop_allow_movement:

            clc                     ; Check for horizontal input. Note that it
            jsr player_move         ; might still be forbidden by the jumping
                                    ; counter or falling flag.
        main_loop_next:

        lda scrolled
        cmp #0
        bne main_loop_after_monsters

        lda #19
        jsr $fff4
        jsr plot_monsters        ; unplot monsters
        jsr move_monsters
        jsr plot_monsters        ; plot monsters

        main_loop_after_monsters:
        clc

        inc monster_movement_counter
        clc

        ; --- Switch character test code (begin) ---
        ldx #157            ; (SPACE)
        jsr check_key
        cpy #255
        bne not_space

        clc
        jsr plot_char
        jsr switch_characters
        jsr plot_char

        not_space:
        ; --- Switch character test code (end) ---

        ldx #143            ; (Escape)
        jsr check_key
        cpy #255
        bne main_loop

    main_loop_endloop:

    jmp main

player_move:

    lda player_jumping
    cmp #0
    beq player_move_check_fall
    clc

    ; Whether moving or not, the player needs to be replotted before any
    ; scrolling occurs because the scrolling routine will replot the player.
    ; This needs to be optimised.

    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot

    jsr player_jump

    jsr plot_player                 ; plot

    lda player_moving
    cmp #1
    bne player_move_not_moving_left

    jsr player_move_left
    clc
    rts

    player_move_not_moving_left:
    cmp #2
    bne player_move_not_moving_right

    jsr player_move_right

    player_move_not_moving_right:

    clc
    rts

    player_move_check_fall:

    lda player_falling
    cmp #0
    beq player_move_check_keys

    clc
    rts

    player_move_check_keys:

    lda #0
    sta player_moving

    ldx #158        ; (Z)
    jsr check_key
    cpy #255
    bne player_move_not_left
    clc

    jsr player_move_left   ; allow the player to jump while moving

    lda #1                  ; 1=moving left
    sta player_moving

    jmp player_move_check_jump

    player_move_not_left:
    clc

    ldx #189        ; (X)
    jsr check_key
    cpy #255
    bne player_move_not_right
    clc

    jsr player_move_right   ; allow the player to jump while moving

    lda #2                  ; 2=moving right
    sta player_moving

    ; jmp player_move_check_jump (fall through)

    player_move_not_right:

    player_move_check_jump:

    lda player_jumping
    cmp #0
    bne player_move_not_jump

    ldx #182        ; (Return)
    jsr check_key
    cpy #255
    bne player_move_not_jump
    clc

    lda #19
    jsr $fff4
    jsr plot_player                 ; unplot

    lda scroll_offset_low
    sta tracking_low
    lda scroll_offset_high
    sta tracking_high
    lda player_y
    sta tracking_y

    jsr player_jump

    jsr plot_player                 ; plot

    player_move_not_jump:

    ldx #151        ; (/)
    jsr check_key
    cpy #255
    bne player_move_not_enter

    jmp player_enter

    player_move_not_enter:

    clc
    rts

check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jmp $fff4   ; Return directly from the OS routine.

check_beneath:      ; Checks beneath the character for solid tiles.
                    ; Sets player_falling if none exist.
    lda player_y
    cmp #21
    bcs check_beneath_demise_exit

    adc #3
    sta $81
    lda player_x
    sta $80

    jsr check_tile
    bcs check_beneath_solid

    inc $80
    jsr check_tile
    bcs check_beneath_solid

    lda bank_number         ; When half way across a cell, check another cell
    cmp #1                  ; beneath the player since they could be standing
    bne check_beneath_fall  ; on one or more of three tiles.

    clc
    inc $80
    jsr check_tile
    bcs check_beneath_solid

    check_beneath_fall:

    lda player_falling
    cmp #0
        bne check_beneath_fall_exit

    lda #1
    sta player_falling

    check_beneath_fall_exit:
    clc
    rts

    check_beneath_demise_exit:

    jsr player_demise

    check_beneath_solid:    ; A solid tile was found.
    clc
    tax

    lda player_falling
    cmp #0
    beq check_beneath_exit

    txa
    cmp #$30                ; Check the tile to see if it is breakable.
    bcc check_beneath_exit

    clc                     ; Increase the tile number in order to set the top
    adc #$18                ; bit after two hits. This requires that the
    sta ($76),y             ; initial tiles have values of 0x31 or higher.
    sta $78

    ; Use the x coordinate of the following span ($74 from check_tile) and the
    ; player's y coordinate ($81) to find the screen location of the tile.
    
    lda $74                 ; Load the position of the current span.
    ldy #1
    adc ($76),y             ; Add the span length (minus the extra unit).
    clc
    sta $75

    lda $81
    sec
    sbc #8
    tax                     ; x=row number

    ; Plot the initial merged tile on bank 2.

    lda $76
    sec     ; C should already be set
    sbc #2
    sta $80
    lda $77
    sbc #0
    sta $81
    clc

    ldy #0
    lda ($80),y
    jsr read_right_sprite_address ; $80,$81=address of the right tile piece

    dec $74 ; Plot the right edge of the previous span with the left edge of
            ; the current one.

    check_beneath_update_tiles:

        lda $74
        jsr read_screen_address_bank2

        lda $78
        jsr read_left_sprite_address ; $70,$71=address of the left tile piece
        jsr plot_merged_tile_bank

        lda $78
        jsr read_right_sprite_address ; $80,$81=address of the right tile piece

        inc $74 ; Now plot the next tile on bank 1.

        lda $74                         ; A=column number
        jsr read_screen_address_bank1

        lda $78
        jsr read_sprite_address     ; Load $70,$71 with the address of the tile.
        jsr plot_tile_bank

        lda $74
        cmp $75
        beq check_beneath_last_tile_bank2

        jmp check_beneath_update_tiles

    check_beneath_last_tile_bank2:

    clc
    lda $76
    adc #2
    sta $76
    lda $77
    adc #0
    sta $77
    clc

    lda $74
    jsr read_screen_address_bank2

    ldy #0
    lda ($76),y
    jsr read_left_sprite_address ; $70,$71=address of the left tile piece
    jsr plot_merged_tile_bank

    check_beneath_exit:

    lda #0
    sta player_falling

    rts

read_row_address:           ; X=row number
                            ; Returns $76,$77 (row address)

    lda row_table_low,x     ; Load entry A from the table.
    sta $76
    lda row_table_high,x
    sta $77

    lda row_indices,x   ; Load index i from the indices;
    asl                 ; and multiply it by 2 to get i*2.
    adc $76             ; Add i*2 to A to get the address, I, of the
    sta $76             ; starting offset and type.
    lda $77
    adc #0
    sta $77
    clc

    rts

player_sprites_low:  .byte <player_left1, <player_left2, <player_right1, <player_right2
player_sprites_high: .byte >player_left1, >player_left2, >player_right1, >player_right2
player_y_offset:     .byte 0, 4

check_tile:         ; $80=x position (0-39)
                    ; $81=y position (0-23) (measured from the top of the
                    ;           playing area, not the top row of the scenery)
                    ; returns C set if tile found or C clear if not

    lda $81         ; For y positions less than 8 do not check the corresponding
    cmp #8          ; row since there are no level spans in these rows.
    bcs check_tile_row

    rts

    check_tile_row:
    sbc #8
    clc

    tax
    jsr read_row_address

    lda initial_row_offsets,x
    sta $74                 ; Store the row offset of the current span.

    cmp $80                   ; If less than the character's x coordinate then
    beq check_tile_spans_loop ; start examining spans until we find one to the
    bcc check_tile_spans_loop ; right of the x coordinate.

    clc
    lda initial_row_tiles,x
    jmp check_tile_visible  ; Check whether the tile is visible and return.

    check_tile_spans_loop:

        clc
        ldy #1
        lda ($76),y         ; Load the number of tiles minus 1, n - 1.
        adc #1              ; n
        bcs check_tile_spans_loop_found
        adc $74             ; Add to the row offset
        bcs check_tile_spans_loop_found

        cmp $80                         ; If the span position is less than or
        beq check_tile_spans_loop_next  ; equal to the x coordinate then loop
        bcc check_tile_spans_loop_next  ; again.

        check_tile_spans_loop_found:

        clc
        ldy #0
        lda ($76),y             ; Load the type number, t,
        jmp check_tile_visible  ; Check whether the tile is visible and return,
                                ; the type number in A, leaving $76,$77
                                ; pointing to the span that was found.

        check_tile_spans_loop_next:

        sta $74             ; Store the new span offset.

        cmp #40
        bpl check_tile_spans_endloop

        lda $76             ; Increment the row address.
        adc #2
        sta $76
        lda $77
        adc #0
        sta $77

        jmp check_tile_spans_loop

    check_tile_spans_endloop:

    clc             ; In theory, we should never reach here.
    rts

; Special tiles have numbers greater or equal to 16 (0x10). The top four bits
; are used to represent properties of each tile: vcdt nnnn.
; v = visible (initial visibility of the tile)
; c = collectable item
; d = door that can be opened with a corresponding key - two consecutive tile
;     numbers are used for the door and key tiles
; t = treasure - a pair of adjacent tiles is used to represent this in the
;     level, and the tile numbers used differ only by the lowest bit

check_tile_visible:             ; A=tile number
                                ; returns C set if tile is visible or C
                                ; clear if not
    cmp #$10
    bcs check_tile_visible_special

    cmp #1                      ; Return C set for tiles 1-15; C clear for 0
    rts

    check_tile_visible_special:

    cmp #$50
    bcc check_tile_visible_not_portal_or_broken

    clc                         ; Portals (> 128) and broken tiles (> 80) are
    rts                         ; not visible.

    check_tile_visible_not_portal_or_broken:

    cmp #$30
    bcs check_tile_visible_breakable

    tay                         ; transfer the tile number to Y
    lda ($82),y                 ; load the visibility of the tile
    cmp #$80
    bcs check_tile_visible_next

    rts                         ; Not visible, and C is clear to indicate this.

    check_tile_visible_breakable:

    cmp #$30                    ; Return C set for tiles 49-63; C clear for 48
    rts

    check_tile_visible_next:    ; the tile is visible

    and #$7f                    ; mask off the visible bit
    cmp #$40                    ; check for collectable objects (vCdtnnnn)
    bcs check_tile_collect_visible_object

    ; Non-collectable (scenery) objects

    and #$3f                    ; mask off visible and collectable bits
    cmp #$20                    ; check for doors that can be opened with a key
                                ; (vcDtnnnn)
    bcc check_tile_visible_exit ; any other visible scenery objects cannot be
                                ; walked through (000tnnnn)

    ; For doors, check the visibility of the corresponding key special tile.
    clc
    sty $8c                     ; temporarily store the special tile number
    tya                         ; a special scenery tile (00Dtnnnn)
    eor #$01                    ; check the corresponding collectable tile
    tay                         ; (00DtnnnN)
    lda ($82),y
    cmp #0
    bne check_tile_visible_exit ; if visible (i.e. not collected) then exit

    ldy $8c                     ; restore the special tile number (00Dtnnnn)
    jmp make_tile_invisible     ; make all tiles of that type invisible and exit

check_tile_collect_visible_object:

    and #$1f                ; mask off the visible, collectable and door bits
    cmp #$10                        ; check for treasure (vcdTnnnn)
    bcs check_tile_collect_treasure ; remove both parts of the object 

    jsr plot_collected_object       ; not treasure, just a regular object
    jmp make_tile_invisible ; make all tiles of this type invisible and exit

check_tile_collect_treasure:

    clc

    jsr plot_collected_object       ; show the item of treasure in the header
    jsr make_tile_invisible         ; make all tiles of this type invisible

    tya
    eor #1                          ; do the same for the corresponding tile
    tay

    jsr plot_collected_object       ; show the item of treasure in the header
    jsr make_tile_invisible         ; make all tiles of this type invisible

    check_tile_visible_exit:
    sec
    rts

make_tile_invisible:    ; Y=special tile number

    lda #0
    sta ($82),y         ; make the tile invisible
    clc
    rts

check_move_right:

    lda bank_number
    cmp #1
    bne check_move_right_continue

    clc             ; If bank 2 is showing, we can move right without checking.
    rts

    check_move_right_continue:
    clc

    lda player_x
    adc #2
    sta $80
    lda player_y
    sta $81
    clc

    jmp check_move  ; branch then exit

player_move_right:

    clc
    jsr check_move_right
    bcs player_move_right_cannot_move

    jmp scroll_right_update     ; branch then exit

    player_move_right_cannot_move:

    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

check_move_left:

    lda bank_number
    cmp #1
    bne check_move_left_continue

    clc             ; If bank 2 is showing, we can move left without checking.
    rts

    check_move_left_continue:
    clc

    lda player_x
    sec
    sbc #1
    sta $80
    clc
    lda player_y
    sta $81

    ; fall through into the next routine

check_move:

    lda #2          ; Start with an offset of 2 from the player's row number.
    sta $7c

    lda #0          ; Use a byte to record occupied tiles. Since we start at
    sta $7d         ; the player's top row, the order of bits is 0000tmb[f] for
                    ; top, middle, bottom and an optional falling bit.
    lda player_falling
    cmp #0
    beq check_move_loop

    inc $7c         ; If the player is falling then we need to check an
                    ; additional tile, below and to the left/right.

    check_move_loop:

        asl $7d
        clc
        jsr check_tile
        bcc check_move_next
        clc

        lda $7d     ; Set a bit to indicate that this tile is occupied.
        ora #1
        sta $7d

        check_move_next:

        inc $81
        dec $7c
        bpl check_move_loop

    lda $7d                 ; If all tiles are empty then allow the move.
    cmp #0
    beq check_move_exit_ok

    lda player_falling      ; If some tiles are not empty while falling then
    cmp #0                  ; stop moving.
    bne check_move_exit_not_ok

    lda player_jumping      ; If some tiles are not empty while jumping then
    cmp #0                  ; stop moving.
    bne check_move_exit_not_ok

    lda $7d                 ; If more than the lowest tile is blocked then
    cmp #$01                ; stop moving.
    bne check_move_exit_not_ok

    jsr plot_player         ; Move the player up by one tile.
    dec player_y            ; We should really check to make sure that there
    jsr plot_player         ; is space above the player to do this.

    clc
    rts

    check_move_exit_not_ok:
    sec
    rts

    check_move_exit_ok:
    clc
    rts

player_move_left:

    clc
    jsr check_move_left
    bcs player_move_left_cannot_move

    jmp scroll_left_update     ; branch then exit

    player_move_left_cannot_move:

    lda #0                      ; stop the player's motion
    sta player_moving
    clc
    rts

jump_steps_y:    .byte 0,1,1,1,1,0,0,0
jump_offsets_ys: .byte 0,0,0,0,1,0,0,0

player_jump:

    clc

    ldx player_jumping      ; Load the number of rows to move.
    lda jump_steps_y,x

    cmp #0                  ; If there are no rows to move then stop jumping.
        beq player_jump_check_after

    lda player_y
    sta $81

    dec $81
    clc

    lda player_x
    sta $80
    jsr check_tile
    bcs player_jump_stop_jumping

    inc $80

    jsr check_tile
    bcs player_jump_stop_jumping

    lda bank_number             ; When half way across a cell, check another
    cmp #1                      ; cell above the player since they could be
        bne player_jump_move_up ; under one or more of three tiles.

    inc $80

    jsr check_tile
    bcs player_jump_stop_jumping

    player_jump_move_up:

        lda $81
        sta player_y

    player_jump_check_after:
    clc

    ldx player_jumping              ; Load the number of rows to move.
    lda jump_offsets_ys,x
    sta player_ys

    inx
    cpx #8                          ; After the end of the list of offsets,
    bcs player_jump_stop_jumping    ; stop jumping.

    stx player_jumping
    clc
    rts

    player_jump_stop_jumping:
    clc

    lda #0
    sta player_jumping
    lda #0
    sta player_ys

    clc
    rts

player_enter:

    clc
    lda player_y
    adc #2
    sta $81
    lda player_x
    sta $80
    jsr check_tile

    cmp #$80
    bcs player_enter_find_portal
    
    rts

    player_enter_find_portal:
    clc

    and #$0f                        ; Obtain the portal number from the lowest
    sta $80                         ; 4 bits and multiply it by 3 to obtain an
    asl                             ; offset into the portal table.
    adc $80
    tax

    lda portal_table_address,x      ; low x
    sta tracking_low
    inx
    lda portal_table_address,x      ; high x
    sta tracking_high
    inx
    lda portal_table_address,x      ; y + 8 blank rows at the top - 2 from the
    adc #6                          ; foot to the head = 6
    sta player_y

    jsr clear_bank1                 ; Clear both banks, just in case the
    jsr clear_bank2                 ; character or any monsters are at the top
                                    ; of the screen,

jump_to_tracking_offset:

    lda scroll_offset_high
    cmp tracking_high
    beq jump_to_tracking_offset_low_check
    bcs jump_to_tracking_offset_left
    bcc jump_to_tracking_offset_right

    jump_to_tracking_offset_low_check:

    lda scroll_offset_low
    cmp tracking_low
    beq jump_to_tracking_offset_exit
    bcc jump_to_tracking_offset_right

    jump_to_tracking_offset_left:
    
    sec
    lda scroll_offset_low
    sbc #1
    sta scroll_offset_low
    lda scroll_offset_high
    sbc #0
    sta scroll_offset_high
    clc

    jsr scroll_left_update_monsters
    jsr scroll_left
    jmp jump_to_tracking_offset

    jump_to_tracking_offset_right:

    lda scroll_offset_low
    adc #1
    sta scroll_offset_low
    lda scroll_offset_high
    adc #0
    sta scroll_offset_high
    clc

    jsr scroll_right_update_monsters
    jsr scroll_right
    jmp jump_to_tracking_offset

    jump_to_tracking_offset_exit:

    jsr initial_plot_bank1
    jsr initial_plot_bank2

    jsr show_bank1
    jmp plot_char                   ; plot the player and exit

fall_steps_y:    .byte 0,0,1,1
fall_offsets_ys: .byte 0,1,0,0

player_fall:        ; sets C if the player is moving horizontally

    lda player_moving
    cmp #1
    bne player_fall_not_moving_left

    jsr player_move_left
    sec
    rts

    player_fall_not_moving_left:

    cmp #2
    bne player_fall_not_moving_right

    jsr player_move_right
    sec
    rts

    player_fall_not_moving_right:

    ; When not moving horizontally, the player character must be unplotted and
    ; replotted because redrawing due to scrolling does not occur.

    lda #19
    jsr $fff4
    jsr plot_player

    jsr player_drop

    jsr plot_player

    rts

player_drop:

    clc
    ldx player_falling
    lda fall_steps_y,x
    adc player_y
    sta player_y

    lda fall_offsets_ys,x
    sta player_ys

    cpx #3                  ; Do not increment the falling counter beyond the
    beq player_drop_exit    ; last falling offset.

    inx
    stx player_falling

    player_drop_exit:
    clc
    rts

player_demise:

    jsr plot_char       ; Unplot the character.

    lda #1
    sta player_lost
    dec player_lives

    rts

track_position: ; Scroll back to the last stored position.

    clc

    lda scroll_offset_high
    cmp tracking_high
    beq track_position_check_low
    bcs track_position_scroll_left
    bcc track_position_scroll_right

    track_position_check_low:
    lda scroll_offset_low
    cmp tracking_low
    beq track_position_check_bank
    bcs track_position_scroll_left
    bcc track_position_scroll_right

    track_position_check_bank:
    lda bank_number
    cmp #0
    beq track_position_exit
    bcs track_position_scroll_left

    track_position_scroll_right:
    jsr scroll_right_update
    sec
    rts

    track_position_scroll_left:
    jsr scroll_left_update
    sec
    rts

    track_position_exit:
    clc
    rts

switch_characters:

    ; Switch the left and right sprites.
    ldx #95
    switch_characters_left_loop:

        ldy player_left1,x
        lda player_left_alt1,x
        sta player_left1,x
        tya
        sta player_left_alt1,x

        ldy player_right1,x
        lda player_right_alt1,x
        sta player_right1,x
        tya
        sta player_right_alt1,x

        dex
        bpl switch_characters_left_loop

    clc
    rts

.include "plotting.oph"
.include "scrolling.oph"
.include "bank_routines.oph"
.include "monsters.oph"

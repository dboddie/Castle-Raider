; Copyright (C) 2014 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

; The following line contains a placeholder address that the build script
; calculates and fills in.

game_completed:

    ; Do something to indicate the game has been completed.
    ; Check whether the player found the treasures.

    ldx #0
    game_completed_text_loop:

        lda completed_text,x
        jsr $ffee
        inx
        cpx #completed_text_length
        bne game_completed_text_loop

    ldx #0
    stx $75
    game_completed_copy_loop:

        lda #4                          ; Draw from column 4 to column 35.
        sta $74
        jsr read_screen_address_bank1   ; $72,$73=address

        lda $72
        sta $78
        sta $76     ; Use $76,$77 for the source address.
        lda $73
        sec
        sbc #$0a    ; Subtract 8 rows ($a00) from the address.
        sta $79
        clc

        lda $79
        adc #$28    ; Find the corresponding bank 2 address.
        sta $77     ; This addition will not cause the carry flag to be set.

        stx $7a
        jsr plot_roll
        ldx $7a

        lda $75
        adc #1                      ; Increment the vertical counter.
        and #$07
        sta $75
        bne game_completed_copy_loop
                                        ; Update the row counter (X) every
        inx                             ; eight pixels.
        cpx #12                         ; If not at the bottom of the area then
        bne game_completed_copy_loop    ; loop again.

    game_completed_wait:

    jmp game_completed_wait

    clc
    rts

plot_roll:      ; $76,$77=start address of a row in the area to be copied
                ; $78,$79=start address of a row in the display area
                ; $75=offset within the row (0 - 7) to start from

    lda $75
    adc #8
    sta $7b     ; Define an end value for the index.

    ldy #0
    ldx $75     ; Use the row offset as an index.

    plot_roll_loop:

        lda $78
        adc roll_row_offsets_low,x
        sta $72
        lda $79
        adc roll_row_offsets_high,x
        sta $73

        lda $76
        adc roll_row_offsets_low,x
        sta $70
        lda $77
        adc roll_row_offsets_high,x
        sta $71

        lda #4                  ; Draw from column 4 to column 35.
        sta $74

        plot_roll_pixel_row_loop: ; Traverse each column in the pixel row.

            lda ($70),y
            sta ($72),y

            jsr next_cell   ; Reuse a plotting routine to increase $72,$73
                            ; by 8 and $74 by 1.

            lda $70
            adc #8
            sta $70
            lda $71
            adc #0
            sta $71

            lda $74
            cmp #36
            bne plot_roll_pixel_row_loop

        inx
        cpx $7b
        bne plot_roll_loop

    plot_roll_exit:

    clc
    rts

completed_text: .byte 17,131, 28,2,16,17,5, 12
                .byte 17,1, 10, " Well done!"
completed_text_end:

.alias completed_text_length [completed_text_end - completed_text]

roll_row_offsets_low:   .byte 0,1,2,3,4,5,6,7,$40,$41,$42,$43,$44,$45,$46
roll_row_offsets_high:  .byte 0,0,0,0,0,0,0,0,1,1,1,1,1,1,1

roll_row_source_offsets: .byte 0,7,6,5,4,3,2,1
